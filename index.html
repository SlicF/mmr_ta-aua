<!DOCTYPE html>
<html lang="pt">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard da Ta√ßa UA</title>
    <link rel="icon" type="image/png" href="assets/ta√ßa_ua.png">
    <link rel="shortcut icon" type="image/png" href="assets/ta√ßa_ua.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script src="debug.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 2px solid #667eea;
        }

        .header h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            color: #666;
            font-size: 1.1em;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto;
            gap: 30px;
            margin-bottom: 30px;
        }

        .quick-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
            max-height: 60px;
            overflow-y: auto;
        }

        .filter-btn {
            padding: 6px 12px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            font-size: 0.8em;
            height: fit-content;
        }

        .filter-btn:hover {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }


        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            border: 1px solid rgba(102, 126, 234, 0.1);
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
        }

        .card-title {
            font-size: 1.3em;
            color: #333;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card-title::before {
            content: '';
            width: 4px;
            height: 25px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 2px;
        }

        .chart-card {
            grid-column: span 2;
        }

        .ranking-card {
            grid-column: span 2;
        }

        .chart-container {
            position: relative;
            height: 400px;
            margin-top: 20px;
        }

        .chart-wrapper {
            position: relative;
            margin-top: 20px;
        }

        .chart-container {
            position: relative;
            height: 550px;
            margin-bottom: 20px;
            padding-left: 30px;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .zoom-controls {
            position: static;
            display: flex;
            gap: 8px;
        }

        .zoom-btn {
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #667eea;
            border-radius: 8px;
            width: 32px;
            height: 32px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 13px;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
            color: #667eea;
        }

        .zoom-btn:hover {
            background: #667eea;
            color: white;
            transform: scale(1.1);
        }

        .zoom-btn.active {
            background: #667eea;
            color: white;
        }

        .quick-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
            max-height: 60px;
            overflow-y: auto;
        }

        .filter-btn {
            padding: 6px 12px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            font-size: 0.8em;
            height: fit-content;
        }

        .team-selector {
            position: relative;
            width: 100%;
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 6px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-top: 10px;
            justify-content: center;
            align-items: center;
        }

        .team-checkbox {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #e9ecef;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
            pointer-events: all;
            backdrop-filter: blur(5px);
            font-size: 0.75em;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            min-height: 26px;
            white-space: nowrap;
            flex-shrink: 0;
            margin: 1px;
        }

        .team-checkbox:hover {
            border-color: #667eea;
            transform: translateY(-2px) scale(1.05);
            background: rgba(255, 255, 255, 1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        }

        .team-checkbox.active {
            background: rgba(102, 126, 234, 0.95);
            color: white;
            border-color: transparent;
            font-weight: 500;
        }

        .team-checkbox.active:hover {
            background: rgba(102, 126, 234, 1);
        }

        .team-checkbox input {
            display: none;
        }

        .team-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.2);
            flex-shrink: 0;
        }

        .team-emblem {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            flex-shrink: 0;
            object-fit: contain;
            padding: 2px;
            box-sizing: border-box;
        }

        .team-name {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Layouts adaptativos para diferentes n√∫meros de equipas */
        .team-selector.few-teams {
            max-height: none;
            overflow: visible;
        }

        .team-selector.medium-teams {
            max-height: none;
            overflow: visible;
        }

        .team-selector.many-teams {
            max-height: none;
            overflow: visible;
        }

        .team-selector.many-teams .team-checkbox {
            font-size: 0.8em;
            padding: 4px 8px;
            min-height: 26px;
        }

        .team-selector.many-teams .team-dot {
            width: 10px;
            height: 10px;
        }

        /* Controles de sele√ß√£o r√°pida */
        .quick-control-btn {
            padding: 6px 12px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8em;
            font-weight: 500;
        }

        .quick-control-btn:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
        }

        /* Barra de scroll personalizada para muitas equipas */
        /* Labels din√¢micos posicionados no final das linhas */
        .team-end-labels {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 5;
        }

        .team-end-label {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid;
            border-radius: 8px;
            padding: 2px 6px;
            font-size: 0.75em;
            font-weight: 500;
            white-space: nowrap;
            backdrop-filter: blur(5px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            transform: translateY(-50%);
            transition: all 0.3s ease;
            display: none;
            z-index: 10;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .team-end-label.visible {
            display: block;
        }

        .team-end-label.group-label {
            background: rgba(255, 255, 255, 0.98);
            font-weight: 600;
            border-width: 3px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.2);
            max-width: 200px;
        }

        .team-end-label:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-50%) scale(1.05);
            z-index: 20;
            max-width: none;
            overflow: visible;
        }

        .previous-season-btn {
            position: absolute;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 0.85em;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
            transition: all 0.3s ease;
            z-index: 1000;
            white-space: nowrap;
            pointer-events: auto;
        }

        .next-season-btn {
            position: absolute;
            background: linear-gradient(135deg, #34d399 0%, #10b981 100%);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 0.85em;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
            transition: all 0.3s ease;
            z-index: 1000;
            white-space: nowrap;
            pointer-events: auto;
        }

        .season-nav-btn:hover {
            transform: scale(1.05);
        }

        .season-nav-btn:active {
            transform: scale(0.98);
        }

        .previous-season-btn:hover {
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.6);
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }

        .next-season-btn:hover {
            box-shadow: 0 6px 16px rgba(16, 185, 129, 0.6);
            background: linear-gradient(135deg, #10b981 0%, #34d399 100%);
        }

        .rankings-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 0.9em;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            overflow: hidden;
        }

        .rankings-table th,
        .rankings-table td {
            padding: 1px 4px;
            text-align: center;
            vertical-align: top;
            line-height: 44px;
            height: 46px;
            box-sizing: border-box;
            margin: 0;
            position: relative;
        }

        .rankings-table th:nth-child(2),
        .rankings-table td:nth-child(2) {
            text-align: left;
            padding: 1px 4px 1px 8px;
            vertical-align: top;
            white-space: nowrap;
            line-height: 44px;
            height: 46px;
            box-sizing: border-box;
            position: relative;
        }

        .rankings-table th:nth-child(2) {
            text-align: center;
            padding: 1px 4px;
        }

        .rankings-table tbody tr:last-child td {
            border-bottom: none;
            padding-bottom: 3px;
        }

        .rankings-table th {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 0.9em;
        }

        .rankings-table th:first-child {
            border-top-left-radius: 10px;
        }

        .rankings-table th:last-child {
            border-top-right-radius: 10px;
        }

        .rankings-table tr:hover {
            background: rgba(102, 126, 234, 0.05);
        }

        /* Novos badges com indicadores de progress√£o integrados */
        .rank-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            color: white;
            font-weight: bold;
            font-size: 0.9em;
            position: relative;
            border: 2px solid transparent;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
            transition: all 0.3s ease;
        }

        .rank-badge:hover {
            transform: scale(1.1);
        }

        /* Cores base dos rankings removidas - agora usamos apenas as cores de progress√£o */

        /* Indicadores de progress√£o com cores completas de fundo */
        .rank-badge.progression-playoffs {
            background: linear-gradient(135deg, #28a745, #20c997);
            border: 2px solid #1e7e34;
            box-shadow: 0 2px 8px rgba(40, 167, 69, 0.4);
        }

        .rank-badge.progression-maintenance-playoffs {
            background: linear-gradient(135deg, #ffc107, #ff9800);
            border: 2px solid #e68900;
            box-shadow: 0 2px 8px rgba(255, 193, 7, 0.4);
        }

        .rank-badge.progression-maintenance-league {
            background: linear-gradient(135deg, #ff9800, #ff6f00);
            border: 2px solid #e65100;
            box-shadow: 0 2px 8px rgba(255, 152, 0, 0.4);
        }

        /* Playoff/Liguilha de Promo√ß√£o (2¬™ divis√£o) - Azul claro */
        .rank-badge.progression-promotion-playoffs {
            background: linear-gradient(135deg, #17a2b8, #138496);
            border: 2px solid #0f6674;
            box-shadow: 0 2px 8px rgba(23, 162, 184, 0.4);
        }

        .rank-badge.progression-promotion-league {
            background: linear-gradient(135deg, #20c997, #17a085);
            border: 2px solid #0e7c68;
            box-shadow: 0 2px 8px rgba(32, 201, 151, 0.4);
        }

        .rank-badge.progression-promotion {
            background: linear-gradient(135deg, #007bff, #0056b3);
            border: 2px solid #004085;
            box-shadow: 0 2px 8px rgba(0, 123, 255, 0.4);
        }

        .rank-badge.progression-relegation {
            background: linear-gradient(135deg, #dc3545, #c82333);
            border: 2px solid #a71e2a;
            box-shadow: 0 2px 8px rgba(220, 53, 69, 0.4);
            animation: pulse-danger 2s infinite;
        }

        .rank-badge.progression-safe {
            background: linear-gradient(135deg, #6c757d, #5a6268);
            border: 2px solid #495057;
            box-shadow: 0 2px 8px rgba(108, 117, 125, 0.3);
        }

        /* Anima√ß√£o para zona de descida */
        @keyframes pulse-danger {

            0%,
            100% {
                box-shadow: 0 0 0 2px rgba(220, 53, 69, 0.2), 0 2px 8px rgba(0, 0, 0, 0.15);
            }

            50% {
                box-shadow: 0 0 0 4px rgba(220, 53, 69, 0.4), 0 2px 12px rgba(220, 53, 69, 0.3);
            }
        }

        /* C√©lula da posi√ß√£o volta ao normal */
        .rankings-table td:first-child {
            position: relative;
            padding-right: 12px;
        }

        /* Legenda dos indicadores */
        .progression-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 18px;
            margin-bottom: 16px;
            padding: 14px 16px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(248, 249, 250, 0.8));
            border-radius: 10px;
            font-size: 0.87em;
            border: 1px solid rgba(0, 0, 0, 0.08);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 500;
            color: #495057;
        }

        .legend-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            color: white;
            font-size: 0.7em;
            font-weight: bold;
            border: 2px solid transparent;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        }

        .legend-badge.legend-playoffs {
            background: linear-gradient(135deg, #28a745, #20c997);
            border: 2px solid #1e7e34;
        }

        .legend-badge.legend-maintenance-playoffs {
            background: linear-gradient(135deg, #ffc107, #ff9800);
            border: 2px solid #e68900;
        }

        .legend-badge.legend-maintenance-league {
            background: linear-gradient(135deg, #ff9800, #ff6f00);
            border: 2px solid #e65100;
        }

        /* Playoff/Liguilha de Promo√ß√£o (2¬™ divis√£o) - Azul claro */
        .legend-badge.legend-promotion-playoffs {
            background: linear-gradient(135deg, #17a2b8, #138496);
            border: 2px solid #0f6674;
        }

        .legend-badge.legend-promotion-league {
            background: linear-gradient(135deg, #20c997, #17a085);
            border: 2px solid #0e7c68;
        }

        .legend-badge.legend-promotion {
            background: linear-gradient(135deg, #007bff, #0056b3);
            border: 2px solid #004085;
        }

        .legend-badge.legend-relegation {
            background: linear-gradient(135deg, #dc3545, #c82333);
            border: 2px solid #a71e2a;
        }

        .legend-badge.legend-safe {
            background: linear-gradient(135deg, #6c757d, #5a6268);
            border: 2px solid #495057;
        }

        .team-emblem-table {
            width: 68px;
            height: 68px;
            border-radius: 6px;
            margin-right: 10px;
            object-fit: contain;
            vertical-align: middle;
            padding: 4px;
            box-sizing: border-box;
            display: inline-block;
        }

        /* Ajuste espec√≠fico para o emblema EGI que n√£o tem margens internas */
        .team-emblem[src*="EGI-07.png"],
        .team-emblem-table[src*="EGI-07.png"] {
            padding: 19px;
        }

        /* Ajuste espec√≠fico do EGI para emblemas pequenos nos seletores */
        .team-checkbox .team-emblem[src*="EGI-07.png"] {
            padding: 6px;
        }

        .team-color-indicator {
            width: 4px;
            height: 28px;
            border-radius: 2px;
            margin-right: 8px;
            display: inline-block;
            vertical-align: middle;
        }

        .team-cell {
            display: flex;
            align-items: center;
            gap: 8px;
            text-align: left !important;
            padding: 8px 0;
        }

        .team-name-table {
            font-weight: bold;
            white-space: normal;
            word-wrap: break-word;
            line-height: 1.3;
            max-width: 300px;
        }

        .team-info-container {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 8px;
            flex: 1;
        }

        .team-elo-info {
            font-size: 0.75em;
            color: #999;
            font-weight: normal;
            white-space: nowrap;
            margin-top: 2px;
        }

        .division-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .group-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            border-top: 1px solid #e0e0e0;
            padding-top: 15px;
        }

        .division-btn,
        .group-btn {
            padding: 10px 20px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .group-btn {
            padding: 8px 16px;
            font-size: 0.9em;
            border-color: #764ba2;
            color: #764ba2;
        }

        .division-btn.active,
        .division-btn:hover {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            transform: translateY(-2px);
        }

        .group-btn.active,
        .group-btn:hover {
            background: linear-gradient(135deg, #764ba2, #667eea);
            color: white;
            transform: translateY(-2px);
        }

        .bracket-container {
            grid-column: span 2;
            overflow-x: auto;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 15px;
            margin-top: 20px;
        }

        .bracket {
            display: flex;
            gap: 30px;
            min-width: 800px;
            justify-content: center;
        }

        .bracket-round {
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 280px;
        }

        .bracket-round h3 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            padding: 10px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .bracket-match {
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
            border-left: 4px solid #667eea;
        }

        .bracket-match:hover {
            transform: translateY(-3px);
        }

        .bracket-team {
            padding: 12px 16px;
            margin: 3px 0;
            border-radius: 6px;
            background: #f8f9fa;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            border-left: 4px solid #dee2e6;
            position: relative;
        }

        .bracket-team.winner {
            color: white;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            border-left-width: 6px;
        }

        .bracket-team:not(.winner):hover {
            background: #e9ecef;
            transform: translateX(2px);
        }

        .bracket-team-content {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
        }

        .bracket-team-emblem {
            width: 48px;
            height: 48px;
            border-radius: 6px;
            object-fit: contain;
            flex-shrink: 0;
        }

        .bracket-team-emblem[src*="EGI-07.png"] {
            padding: 10px;
            box-sizing: border-box;
        }

        .score {
            font-weight: bold;
            font-size: 0.9em;
        }

        /* Indicadores de ELO no bracket */
        .bracket-elo-change {
            font-size: 0.75em;
            font-weight: 600;
            padding: 2px 5px;
            border-radius: 3px;
            white-space: nowrap;
            margin-left: 8px;
        }

        .bracket-elo-change.positive {
            color: #28a745;
            background: rgba(40, 167, 69, 0.15);
        }

        .bracket-elo-change.negative {
            color: #dc3545;
            background: rgba(220, 53, 69, 0.15);
        }

        .unknown-result-indicator {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 4px;
            padding: 4px 8px;
            margin-top: 5px;
            text-align: center;
        }

        .unknown-result-indicator small {
            color: #856404 !important;
            font-size: 0.75em;
            font-weight: 500;
        }

        /* Labels de qualifica√ß√£o nos brackets */
        .qualification-label {
            font-size: 0.7em;
            color: #666;
            font-style: italic;
            padding: 2px 8px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 3px;
            text-align: center;
            margin: 2px 0;
        }

        .qualification-label-top {
            margin-bottom: 5px;
            margin-top: -5px;
        }

        .qualification-label-bottom {
            margin-top: 5px;
            margin-bottom: -5px;
        }

        .bracket-legend {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .bracket-legend h4 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 0.95em;
            text-align: center;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 10px;
        }

        .bracket-legend-items {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .bracket-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 6px;
            font-size: 0.85em;
            border-left: 4px solid #667eea;
        }

        .bracket-legend-item.playoff {
            border-left-color: #28a745;
        }

        .bracket-legend-item.promotion-playoff,
        .bracket-legend-item.promotion-league {
            border-left-color: #17a2b8;
        }

        .bracket-legend-item.maintenance-playoff,
        .bracket-legend-item.maintenance-league {
            border-left-color: #ffc107;
        }

        .bracket-legend-badge {
            font-weight: bold;
            background: white;
            padding: 4px 8px;
            border-radius: 4px;
            min-width: 30px;
            text-align: center;
        }

        .bracket-league-table {
            background: white;
            border-radius: 10px;
            padding: 35px;
            margin-top: 20px;
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
        }

        .bracket-league-table h3 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .bracket-league-table table {
            width: 100%;
            border-collapse: collapse;
            font-size: 17px;
        }

        .bracket-league-table th {
            background: #667eea;
            color: white;
            padding: 14px 12px;
            text-align: center;
            font-weight: 600;
            font-size: 16px;
        }

        .bracket-league-table td {
            padding: 14px 12px;
            border-bottom: 1px solid #eee;
            text-align: center;
        }

        .bracket-league-table td.team-cell {
            text-align: left;
        }

        .bracket-league-table tr:hover {
            background: #f8f9fa;
        }

        .bracket-league-table .position {
            font-weight: bold;
            text-align: center;
            width: 40px;
        }

        .bracket-league-table .team-cell {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bracket-league-table .team-emblem {
            width: 50px;
            height: 50px;
            object-fit: contain;
            margin-right: 10px;
        }

        .bracket-league-table .team-qualification-label {
            display: inline-block;
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 4px;
            margin-right: 12px;
            font-weight: 600;
            white-space: nowrap;
        }

        .bracket-league-table .qual-1div {
            background: #e3f2fd;
            color: #1976d2;
            border: 1px solid #1976d2;
        }

        .bracket-league-table .qual-2div {
            background: #fff3e0;
            color: #f57c00;
            border: 1px solid #f57c00;
        }

        @media (max-width: 768px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }

            .chart-card,
            .bracket-container {
                grid-column: span 1;
            }

            .chart-wrapper {
                height: 400px;
            }

            .team-selector {
                position: relative;
                width: 100%;
                height: auto;
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                gap: 6px;
                padding: 15px;
                background: #f8f9fa;
                border-radius: 10px;
                margin-top: 15px;
                right: auto;
                top: auto;
                bottom: auto;
                min-width: auto;
                max-width: none;
                justify-content: center;
            }

            .team-checkbox {
                transform: none !important;
                font-size: 0.8em;
                padding: 4px 8px;
                min-height: 28px;
                margin: 1px;
            }

            .team-end-labels {
                display: none;
                /* Ocultar labels din√¢micos no mobile */
            }

            .quick-selection-controls {
                flex-direction: column;
                gap: 5px !important;
            }

            .quick-control-btn {
                font-size: 0.75em !important;
                padding: 4px 8px !important;
            }

            .team-selector.many-teams {
                max-height: none;
            }

            .division-selector {
                flex-wrap: wrap;
            }
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
            font-size: 1.1em;
            color: #666;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        .modalidade-selector {
            text-align: center;
            margin-bottom: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .modalidade-selector label {
            font-weight: 600;
            margin-right: 8px;
            font-size: 1.1em;
            color: #333;
        }

        .modalidade-selector select {
            padding: 10px 16px;
            border: 2px solid #667eea;
            border-radius: 12px;
            font-size: 1em;
            cursor: pointer;
            background: white;
            transition: all 0.3s ease;
        }

        .modalidade-selector select:hover {
            border-color: #764ba2;
            background: #f7f7ff;
        }


        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Estilos do Calend√°rio de Jogos */
        .calendar-card {
            margin-top: 30px;
            grid-column: 1 / -1;
            /* Ocupa toda a largura do grid */
        }

        .calendar-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .jornada-navigation {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
            margin-bottom: 20px;
        }

        .jornada-arrow-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .jornada-arrow {
            background: transparent;
            color: #667eea;
            border: none;
            width: auto;
            height: auto;
            font-size: 2em;
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 5px 15px;
            font-weight: bold;
        }

        .jornada-arrow:hover:not(:disabled) {
            color: #764ba2;
            transform: scale(1.2);
        }

        .jornada-arrow:disabled {
            color: #ccc;
            cursor: not-allowed;
            opacity: 0.3;
        }

        .epoca-switch-label {
            font-size: 0.75em;
            color: #667eea;
            cursor: pointer;
            padding: 2px 8px;
            border-radius: 4px;
            background: rgba(102, 126, 234, 0.1);
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .epoca-switch-label:hover {
            background: rgba(102, 126, 234, 0.2);
            transform: translateY(-2px);
        }

        .jornada-title {
            font-size: 1.5em;
            font-weight: 700;
            color: #333;
            min-width: 180px;
            text-align: center;
        }

        .games-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .game-item {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .game-item:hover {
            background: #e9ecef;
            border-color: #667eea;
            transform: translateX(2px);
        }

        .game-item.played {
            background: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .game-item.not-played {
            background: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .game-date {
            min-width: 100px;
            font-size: 0.9em;
            color: #666;
            font-weight: 500;
            flex-shrink: 0;
        }

        .game-teams {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-right: 135px;
        }

        .game-team {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 320px;
        }

        .game-team.home {
            justify-content: flex-end;
            text-align: right;
        }

        .game-team.away {
            justify-content: flex-start;
            text-align: left;
        }

        .game-team-emblem {
            width: 72px;
            height: 72px;
            object-fit: contain;
            flex-shrink: 0;
        }

        .game-team-emblem[src*="EGI-07.png"] {
            width: 66px;
            height: 66px;
            padding: 15px;

        }

        .game-team-name {
            font-weight: 600;
            color: #333;
            width: 180px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .game-team.home .game-team-name {
            text-align: right;
        }

        .game-team.away .game-team-name {
            text-align: left;
        }

        .game-elo-change {
            font-size: 0.85em;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 4px;
            white-space: nowrap;
        }

        .game-elo-change.positive {
            color: #28a745;
            background: rgba(40, 167, 69, 0.1);
        }

        .game-elo-change.negative {
            color: #dc3545;
            background: rgba(220, 53, 69, 0.1);
        }

        .game-score {
            font-size: 1.3em;
            font-weight: bold;
            color: #333;
            min-width: 80px;
            text-align: center;
        }

        .game-vs {
            color: #999;
            font-weight: 600;
            font-size: 0.9em;
        }

        .no-games-message {
            text-align: center;
            color: #666;
            padding: 40px;
            font-size: 1.1em;
        }

        @media (max-width: 768px) {
            .game-item {
                flex-direction: column;
                gap: 12px;
            }

            .game-teams {
                flex-direction: column;
                width: 100%;
                gap: 10px;
            }

            .game-team {
                width: 100%;
                min-width: auto;
            }

            .game-team.home,
            .game-team.away {
                justify-content: space-between;
                flex-direction: row;
            }

            .game-score {
                min-width: auto;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>Dashboard da Ta√ßa UA</h1>
        </div>

        <div class="modalidade-selector">
            <label for="epoca">√âpoca:</label>
            <select id="epoca" name="epoca">
                <!-- √âpocas ser√£o carregadas dinamicamente -->
            </select>

            <label for="modalidade">Modalidade:</label>
            <select id="modalidade" name="modalidade">
                <!-- Modalidades ser√£o carregadas dinamicamente baseadas na √©poca -->
            </select>
        </div>

        <div class="dashboard-grid">
            <!-- Gr√°fico de ELO -->
            <div class="card chart-card">
                <!-- Filtros r√°pidos -->
                <div class="quick-filters" id="quickFilters">
                    <!-- Filtros ser√£o gerados dinamicamente baseados na modalidade -->
                </div>
                <div class="chart-header">
                    <div class="card-title">Evolu√ß√£o de ELO das Equipas</div>
                    <div class="zoom-controls">
                        <button class="zoom-btn" data-zoom="in" title="Zoom In">üîç+</button>
                        <button class="zoom-btn" data-zoom="out" title="Zoom Out">üîç-</button>
                        <button class="zoom-btn" data-zoom="reset" title="Reset Zoom">‚ü≤</button>
                        <button class="zoom-btn" data-action="toggle-pan" id="panModeBtn" title="Pan Mode">‚úã</button>
                    </div>
                </div>
                <div class="chart-wrapper">
                    <div class="chart-container">
                        <canvas id="eloChart"></canvas>
                        <div class="team-end-labels" id="teamEndLabels">
                            <!-- Labels din√¢micos ser√£o gerados aqui -->
                        </div>
                    </div>
                    <div class="team-selector" id="teamSelector">
                        <!-- Checkboxes ser√£o gerados dinamicamente -->
                    </div>
                </div>
            </div>

            <!-- Tabela de Classifica√ß√£o -->
            <div class="card ranking-card">
                <div class="card-title">Classifica√ß√£o Geral</div>
                <div class="division-selector" id="divisionSelector">
                    <!-- Bot√µes de divis√£o ser√£o gerados dinamicamente -->
                </div>
                <div class="group-selector" id="groupSelector" style="display: none;">
                    <!-- Bot√µes de grupo ser√£o gerados dinamicamente -->
                </div>

                <!-- Legenda dos indicadores de progress√£o (gerada dinamicamente) -->
                <div class="progression-legend" id="progressionLegend" style="display: none;">
                    <!-- Ser√° preenchido dinamicamente via JavaScript -->
                </div>

                <table class="rankings-table" id="rankingsTable">
                    <thead>
                        <tr>
                            <th>Pos.</th>
                            <th>Equipa</th>
                            <th>Pts</th>
                            <th>J</th>
                            <th>V</th>
                            <th>E</th>
                            <th>D</th>
                            <th style="color: red;">FC</th>
                            <th>GM</th>
                            <th>GS</th>
                            <th>¬±</th>
                        </tr>
                    </thead>
                    <tbody id="rankingsBody">
                        <!-- Dados ser√£o preenchidos dinamicamente -->
                    </tbody>
                </table>
            </div>

            <!-- Calend√°rio de Jogos -->
            <div class="card calendar-card">
                <div class="card-title">Calend√°rio de Jogos</div>

                <!-- Navega√ß√£o de Jornadas -->
                <div class="jornada-navigation">
                    <div class="jornada-arrow-container">
                        <button class="jornada-arrow" id="prevJornadaBtn" data-jornada-nav="prev"
                            title="Jornada anterior">
                            &lt;
                        </button>
                        <div class="epoca-switch-label" id="prevEpocaLabel" style="display: none;"></div>
                    </div>
                    <div class="jornada-title" id="jornadaTitle">
                        Selecione uma modalidade
                    </div>
                    <div class="jornada-arrow-container">
                        <button class="jornada-arrow" id="nextJornadaBtn" data-jornada-nav="next"
                            title="Jornada seguinte">
                            &gt;
                        </button>
                        <div class="epoca-switch-label" id="nextEpocaLabel" style="display: none;"></div>
                    </div>
                </div>

                <!-- Seletores de Divis√£o e Grupo (igual √† classifica√ß√£o) -->
                <div class="division-selector" id="calendarDivisionSelector" style="display: none;">
                    <!-- Bot√µes de divis√£o ser√£o gerados dinamicamente -->
                </div>
                <div class="group-selector" id="calendarGroupSelector" style="display: none;">
                    <!-- Bot√µes de grupo ser√£o gerados dinamicamente -->
                </div>

                <div class="games-list" id="gamesList">
                    <div class="no-games-message">Selecione uma modalidade para ver os jogos</div>
                </div>
            </div>
        </div>

        <!-- Bracket -->
        <div class="card">
            <div class="card-title">Bracket de Elimina√ß√£o</div>
            <div class="bracket-container">
                <div class="bracket" id="bracketContainer">
                    <!-- Bracket ser√° gerado dinamicamente -->
                </div>
            </div>
        </div>

        <!-- Bracket Secund√°rio (Manuten√ß√£o/Promo√ß√£o) -->
        <div class="card" id="secondaryBracketCard" style="display: none;">
            <div class="card-title" id="secondaryBracketTitle">Playoff/Liguilha</div>
            <div class="bracket-container">
                <div class="bracket" id="secondaryBracketContainer">
                    <!-- Bracket secund√°rio ser√° gerado dinamicamente -->
                </div>
            </div>
        </div>
    </div>

    <!-- Debug Panel (oculto por padr√£o) -->
    <div id="debug-panel"
        style="display: none; position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.9); color: white; padding: 10px; border-radius: 5px; z-index: 10000; font-family: monospace; font-size: 12px;">
        <div style="margin-bottom: 10px; font-weight: bold;">üêõ Debug Panel</div>
        <button data-debug="enable" style="margin: 2px; padding: 5px; font-size: 11px;">Ativar Debug</button>
        <button data-debug="enable-all" style="margin: 2px; padding: 5px; font-size: 11px;">Debug Verbose</button>
        <button data-debug="disable" style="margin: 2px; padding: 5px; font-size: 11px;">Desativar</button>
        <button data-debug="close" style="margin: 2px; padding: 5px; font-size: 11px;">Fechar</button>
    </div>

    <script>
        // Mostrar painel de debug com Ctrl+Shift+D
        document.addEventListener('keydown', function (e) {
            if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                e.preventDefault();
                const panel = document.getElementById('debug-panel');
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            }
        });

        // Inicializar aplica√ß√£o
        async function initApp() {
            // Carregar configura√ß√£o dos cursos
            await loadCoursesConfig();

            // Inicializar seletores de √©poca e modalidade
            initializeSelectors();

            // N√£o carregar dados inicialmente - aguardar sele√ß√£o de modalidade
            document.getElementById('teamSelector').innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">Selecione uma modalidade para ver os dados</p>';
            document.getElementById('rankingsBody').innerHTML = '<tr><td colspan="11" style="text-align: center; color: #666;">Selecione uma modalidade</td></tr>';
            document.getElementById('bracketContainer').innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">Selecione uma modalidade para ver o bracket</p>';

            // Inicializar gr√°fico vazio
            initEloChart();
        }

        // Criar seletor de equipas
        function createTeamSelector() {
            const selector = document.getElementById('teamSelector');
            selector.innerHTML = '';

            if (sampleData.teams.length === 0) {
                selector.innerHTML = '<p style="color: #666; text-align: center;">Selecione uma modalidade primeiro</p>';
                return;
            }

            // Aplicar layout inteligente baseado no n√∫mero de equipas
            applyIntelligentTeamLayout(selector, sampleData.teams.length);

            sampleData.teams.forEach(team => {
                const label = document.createElement('label');
                label.className = 'team-checkbox active';

                // Criar elemento para o emblema
                const emblemHtml = team.emblemPath ?
                    `<img src="${team.emblemPath}" alt="${team.name}" class="team-emblem" style="margin-right: 4px;" onerror="this.style.display='none'">` :
                    '';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `team-${team.name.replace(/[^a-zA-Z0-9]/g, '_')}`;
                checkbox.name = checkbox.id;
                checkbox.checked = true;
                checkbox.dataset.teamName = team.name;

                const teamDot = document.createElement('div');
                teamDot.className = 'team-dot';
                teamDot.style.backgroundColor = team.color;

                const teamNameSpan = document.createElement('span');
                teamNameSpan.className = 'team-name';
                teamNameSpan.title = team.fullName;
                teamNameSpan.textContent = team.name;

                label.appendChild(checkbox);
                if (team.emblemPath) {
                    const emblem = document.createElement('img');
                    emblem.src = team.emblemPath;
                    emblem.alt = team.name;
                    emblem.className = 'team-emblem';
                    emblem.style.marginRight = '4px';
                    emblem.onerror = () => emblem.style.display = 'none';
                    label.appendChild(emblem);
                }
                label.appendChild(teamDot);
                label.appendChild(teamNameSpan);

                label.title = team.fullName;
                selector.appendChild(label);
            });

            // Se h√° muitas equipas, adicionar controles de sele√ß√£o r√°pida
            if (sampleData.teams.length > 12) {
                addQuickSelectionControls(selector);
            }

            // Inicializar indicador de equipas
            setTimeout(updateTeamCountIndicator, 100);
        }

        // Fun√ß√£o para aplicar layout inteligente baseado no n√∫mero de equipas
        function applyIntelligentTeamLayout(selector, teamCount) {
            // Remover classes de layout anterior
            selector.classList.remove('many-teams', 'few-teams', 'medium-teams');

            if (teamCount <= 8) {
                // Poucas equipas: layout normal com boa margem
                selector.classList.add('few-teams');
                selector.style.gap = '12px';
            } else if (teamCount <= 16) {
                // N√∫mero m√©dio: layout compacto mas leg√≠vel
                selector.classList.add('medium-teams');
                selector.style.gap = '8px';
            } else {
                // Muitas equipas: layout muito compacto com scrolling horizontal se necess√°rio
                selector.classList.add('many-teams');
                selector.style.gap = '6px';
            }
        }

        // Fun√ß√£o para adicionar controles de sele√ß√£o r√°pida
        function addQuickSelectionControls(selector) {
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'quick-selection-controls';
            controlsDiv.style.cssText = `
                width: 100%;
                display: flex;
                justify-content: center;
                gap: 10px;
                margin-bottom: 10px;
                padding: 10px;
                background: rgba(102, 126, 234, 0.1);
                border-radius: 8px;
            `;

            const selectAllBtn = document.createElement('button');
            selectAllBtn.textContent = 'Seleccionar Todas';
            selectAllBtn.className = 'quick-control-btn';
            selectAllBtn.onclick = () => selectAllTeams(true);

            const deselectAllBtn = document.createElement('button');
            deselectAllBtn.textContent = 'Desseleccionar Todas';
            deselectAllBtn.className = 'quick-control-btn';
            deselectAllBtn.onclick = () => selectAllTeams(false);

            const toggleBtn = document.createElement('button');
            toggleBtn.textContent = 'Inverter Sele√ß√£o';
            toggleBtn.className = 'quick-control-btn';
            toggleBtn.onclick = toggleAllTeams;

            controlsDiv.appendChild(selectAllBtn);
            controlsDiv.appendChild(deselectAllBtn);
            controlsDiv.appendChild(toggleBtn);

            selector.prepend(controlsDiv);
        }

        // Fun√ß√µes de controle r√°pido
        function selectAllTeams(select) {
            const checkboxes = document.querySelectorAll('#teamSelector input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                const label = checkbox.parentElement;
                checkbox.checked = select;
                if (select) {
                    label.classList.add('active');
                } else {
                    label.classList.remove('active');
                }
            });
            updateEloChart();
            updateTeamCountIndicator();
        }

        function toggleAllTeams() {
            const checkboxes = document.querySelectorAll('#teamSelector input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                const label = checkbox.parentElement;
                checkbox.checked = !checkbox.checked;
                if (checkbox.checked) {
                    label.classList.add('active');
                } else {
                    label.classList.remove('active');
                }
            });
            updateEloChart();
            updateTeamCountIndicator();
        }

        // Alternar visibilidade da equipa no gr√°fico
        function toggleTeam(teamName) {
            const checkbox = event.target;
            const label = checkbox.parentElement;

            if (checkbox.checked) {
                label.classList.add('active');
            } else {
                label.classList.remove('active');
            }

            updateEloChart();
            updateTeamCountIndicator();
        }

        // Fun√ß√£o para atualizar indicador de n√∫mero de equipas selecionadas
        function updateTeamCountIndicator() {
            const activeCount = document.querySelectorAll('#teamSelector input[type="checkbox"]:checked').length;
            const totalCount = document.querySelectorAll('#teamSelector input[type="checkbox"]').length;

            let indicator = document.getElementById('team-count-indicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'team-count-indicator';
                indicator.style.cssText = `
                    position: absolute;
                    top: 10px;
                    right: 15px;
                    background: rgba(102, 126, 234, 0.9);
                    color: white;
                    padding: 4px 8px;
                    border-radius: 10px;
                    font-size: 0.75em;
                    font-weight: 500;
                    z-index: 15;
                    transition: all 0.3s ease;
                `;
                document.querySelector('.chart-container').appendChild(indicator);
            }

            indicator.textContent = `${activeCount}/${totalCount} equipas`;

            // Mudar cor baseado na quantidade
            if (activeCount > 12) {
                indicator.style.background = 'rgba(220, 53, 69, 0.9)'; // Vermelho - muitas equipas
            } else if (activeCount > 8) {
                indicator.style.background = 'rgba(255, 193, 7, 0.9)'; // Amarelo - n√∫mero m√©dio
            } else {
                indicator.style.background = 'rgba(40, 167, 69, 0.9)'; // Verde - poucas equipas
            }
        }

        // Criar seletor de divis√µes
        // Criar seletor de divis√µes (usa DivisionSelector class)
        function createDivisionSelector() {
            divisionSelector.render();
        }

        // Atualizar bot√µes visuais da classifica√ß√£o
        function updateRankingsDivisionButtons() {
            divisionSelector.setActive(appState.view.division);
        }

        // Trocar divis√£o
        function switchDivision(division) {
            divisionSelector.setActive(division);
            groupSelector.render();
            updateRankingsTable();
            syncCalendarWithRankings();
        }

        // Atualizar seletor de grupos (usa GroupSelector class)
        function updateGroupSelector() {
            groupSelector.render();
        }

        // Atualizar bot√µes visuais de grupo da classifica√ß√£o
        function updateRankingsGroupButtons() {
            groupSelector.setActive(appState.view.group ? `Grupo ${appState.view.group}` : '');
        }

        // Trocar grupo
        function switchGroup(group) {
            groupSelector.setActive(group ? `Grupo ${group}` : '');
            updateRankingsTable();
            syncCalendarWithRankings();
        }

        // Inicializar gr√°fico ELO
        function initEloChart() {
            const ctx = document.getElementById('eloChart').getContext('2d');

            eloChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: false
                        },
                        zoom: {
                            pan: {
                                enabled: false,
                                mode: 'xy',
                                modifierKey: null,
                                onPanComplete: function () {
                                    setTimeout(updateDynamicTeamLabels, 100);
                                }
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
                                    speed: 0.1
                                },
                                pinch: {
                                    enabled: true
                                },
                                drag: {
                                    enabled: false,
                                    backgroundColor: 'rgba(225,225,225,0.3)'
                                },
                                mode: 'xy',
                                onZoomComplete: function () {
                                    setTimeout(updateDynamicTeamLabels, 100);
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            ticks: {
                                padding: 10
                            },
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            }
                        },
                        x: {
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            },
                            ticks: {
                                padding: 5
                            }
                        }
                    },
                    elements: {
                        line: {
                            tension: 0.3
                        },
                        point: {
                            radius: 4,
                            hoverRadius: 6
                        }
                    },
                    layout: {
                        padding: {
                            right: 50
                        }
                    }
                }
            });

            // Adicionar funcionalidade de pan manual
            setupManualPan();
        }

        // Configurar pan manual com eventos de mouse
        function setupManualPan() {
            const canvas = eloChart.canvas;

            canvas.addEventListener('mousedown', function (event) {
                if (!appState.chart.pan.enabled || !eloChart) return;

                appState.chart.pan.isPanning = true;
                appState.chart.pan.startX = event.clientX;
                appState.chart.pan.startY = event.clientY;
                canvas.style.cursor = 'grabbing';
            });

            canvas.addEventListener('mousemove', function (event) {
                if (!appState.chart.pan.isPanning || !appState.chart.pan.enabled || !eloChart) return;

                const deltaX = event.clientX - appState.chart.pan.startX;
                const deltaY = event.clientY - appState.chart.pan.startY;

                const xScale = eloChart.scales.x;
                const yScale = eloChart.scales.y;

                // Calcular movimento proporcional
                const xRange = xScale.max - xScale.min;
                const yRange = yScale.max - yScale.min;

                const xMovement = -(deltaX / canvas.width) * xRange;
                const yMovement = (deltaY / canvas.height) * yRange;

                // Aplicar pan
                eloChart.options.scales.x.min = (eloChart.options.scales.x.min || xScale.min) + xMovement;
                eloChart.options.scales.x.max = (eloChart.options.scales.x.max || xScale.max) + xMovement;
                eloChart.options.scales.y.min = (eloChart.options.scales.y.min || yScale.min) + yMovement;
                eloChart.options.scales.y.max = (eloChart.options.scales.y.max || yScale.max) + yMovement;

                eloChart.update('none');
                updateDynamicTeamLabels();

                appState.chart.pan.startX = event.clientX;
                appState.chart.pan.startY = event.clientY;
            });

            canvas.addEventListener('mouseup', function () {
                if (appState.chart.pan.isPanning) {
                    appState.chart.pan.isPanning = false;
                    canvas.style.cursor = appState.chart.pan.enabled ? 'grab' : 'default';
                }
            });

            canvas.addEventListener('mouseleave', function () {
                if (appState.chart.pan.isPanning) {
                    appState.chart.pan.isPanning = false;
                    canvas.style.cursor = 'default';
                }
            });

            // Fun√ß√£o global para ativar/desativar pan
            window.toggleManualPan = function () {
                appState.chart.pan.enabled = !appState.chart.pan.enabled;
                canvas.style.cursor = appState.chart.pan.enabled ? 'grab' : 'default';

                const panButton = document.getElementById('panButton');
                panButton.textContent = appState.chart.pan.enabled ? 'ü§ö Pan: ON' : '‚úã Pan: OFF';
                panButton.classList.toggle('active', appState.chart.pan.enabled);
            };
        }

        // Atualizar gr√°fico ELO
        function updateEloChart() {
            if (!eloChart || !sampleData.teams || sampleData.teams.length === 0) {
                DebugUtils.debugEloChart('insufficient_data');
                return;
            }

            DebugUtils.debugEloChart('updating');

            const datasets = [];
            const checkboxes = document.querySelectorAll('#teamSelector input[type="checkbox"]');

            // Verificar se existem ajustes intergrupos reais nos dados atuais
            const hasAdjustments = currentModalityHasAdjustments;

            // Criar labels com datas formatadas e identifica√ß√£o das fases
            let labels = [];
            if (sampleData.gamesDates && sampleData.gamesDates.length > 0) {
                // Contadores para identificar fases dos playoffs
                let playoffPhaseIndex = 0;
                const playoffPhases = ['Quartos', 'Meias', '3¬∫ Lugar', 'Final']; // E1, E2, E3L, E3
                let regularSeasoneEnded = false;

                // Calcular quantas jornadas de fase de grupos existem
                // Usar o valor pr√©-calculado do calend√°rio completo
                let regularSeasonGames = sampleData.totalRegularSeasonGames || 0;

                // Se n√£o temos do calend√°rio, tentar calcular dos jogos j√° jogados (fallback)
                if (regularSeasonGames === 0 && sampleData.rawEloData && sampleData.rawEloData.length > 0) {
                    const regularRounds = sampleData.rawEloData
                        .filter(match => match.Jornada && !isNaN(parseInt(match.Jornada)))
                        .map(match => parseInt(match.Jornada));
                    regularSeasonGames = regularRounds.length > 0 ? Math.max(...regularRounds) : 0;
                }

                // N√ÉO calcular automaticamente - usar apenas o n√∫mero real de jornadas dos dados
                // (modalidades t√™m estruturas diferentes: divis√µes, grupos, etc)

                labels = sampleData.gamesDates.map((date, index) => {
                    if (date instanceof Date) {
                        if (index === 0) {
                            return 'In√≠cio'; // Primeira data √© o in√≠cio da √©poca
                        } else if (index === sampleData.gamesDates.length - 1 && hasAdjustments) {
                            // Verificar se √© a √∫ltima data e h√° ajustes intergrupos reais
                            return `Ajustes (${date.toLocaleDateString('pt-PT', { day: '2-digit', month: '2-digit' })})`;
                        }

                        // Verificar se j√° passou da fase de grupos
                        if (index > regularSeasonGames && !regularSeasoneEnded) {
                            regularSeasoneEnded = true;
                            playoffPhaseIndex = 0;
                        }

                        if (regularSeasoneEnded && playoffPhaseIndex < playoffPhases.length) {
                            const label = `${playoffPhases[playoffPhaseIndex]} (${date.toLocaleDateString('pt-PT', { day: '2-digit', month: '2-digit' })})`;
                            playoffPhaseIndex++;
                            return label;
                        }

                        return date.toLocaleDateString('pt-PT', { day: '2-digit', month: '2-digit' });
                    }
                    return index === 0 ? 'In√≠cio' : 'Data desconhecida';
                });

                // Adicionar labels vazias at√© meio da temporada
                // labels.length - 1 porque o primeiro √© "In√≠cio", n√£o uma jornada
                const jornadasFeitas = labels.length - 1;
                const meioTemporada = Math.ceil(regularSeasonGames / 2);

                // Se ainda n√£o passou do meio da temporada, adicionar espa√ßos at√© ao total previsto
                // Se j√° passou do meio, n√£o adicionar mais espa√ßos vazios
                let labelsVazias = 0;
                if (jornadasFeitas < meioTemporada) {
                    labelsVazias = regularSeasonGames - jornadasFeitas;
                }

                if (labelsVazias > 0) {
                    for (let i = 0; i < labelsVazias; i++) {
                        labels.push('');
                    }
                }

                // Adicionar ponto extra no in√≠cio para "√âpoca Anterior" (s√≥ se houver √©poca anterior)
                const currentEpochElement = document.getElementById('epoca');
                if (currentEpochElement) {
                    const currentEpoch = currentEpochElement.value;
                    const currentIndex = availableEpocas.indexOf(currentEpoch);
                    if (currentIndex < availableEpocas.length - 1) {
                        labels.unshift('√âpoca Anterior');
                    }
                }
            } else {
                // Fallback para jornadas se n√£o houver datas
                let maxRounds = 0;
                sampleData.teams.forEach(team => {
                    if (sampleData.eloHistory[team.name] && sampleData.eloHistory[team.name].length > maxRounds) {
                        maxRounds = sampleData.eloHistory[team.name].length;
                    }
                });
                labels = Array.from({ length: maxRounds }, (_, i) => i === 0 ? 'In√≠cio' : `Jornada ${i}`);

                // Adicionar "Ajustes" s√≥ se h√° ajustes reais
                if (hasAdjustments && labels.length > 1) {
                    labels[labels.length - 1] = 'Ajustes';
                }

                // Calcular n√∫mero de jornadas regulares previstas
                // Primeiro tentar do calend√°rio (csv_modalidades), depois dos resultados (detalhe)
                let regularSeasonGames = sampleData.totalRegularSeasonGames || 0;

                // Se n√£o temos do calend√°rio, tentar dos resultados j√° jogados
                if (regularSeasonGames === 0 && sampleData.rawEloData && sampleData.rawEloData.length > 0) {
                    const regularRounds = sampleData.rawEloData
                        .filter(match => match.Jornada && !isNaN(parseInt(match.Jornada)))
                        .map(match => parseInt(match.Jornada));
                    regularSeasonGames = regularRounds.length > 0 ? Math.max(...regularRounds) : 0;
                }

                // N√ÉO calcular automaticamente - usar apenas o n√∫mero real de jornadas dos dados
                // (modalidades t√™m estruturas diferentes: divis√µes, grupos, etc)

                // Adicionar labels vazias at√© meio da temporada
                // labels.length - 1 porque o primeiro √© "In√≠cio", n√£o uma jornada
                const jornadasFeitas = labels.length - 1;
                const meioTemporada = Math.ceil(regularSeasonGames / 2);

                // Se ainda n√£o passou do meio da temporada, adicionar espa√ßos at√© ao total previsto
                // Se j√° passou do meio, n√£o adicionar mais espa√ßos vazios
                let labelsVazias = 0;
                if (jornadasFeitas < meioTemporada) {
                    labelsVazias = regularSeasonGames - jornadasFeitas;
                }

                if (labelsVazias > 0) {
                    for (let i = 0; i < labelsVazias; i++) {
                        labels.push('');
                    }
                }

                // Adicionar ponto extra no in√≠cio para "√âpoca Anterior" (s√≥ se houver √©poca anterior)
                const currentEpochElement = document.getElementById('epoca');
                if (currentEpochElement) {
                    const currentEpoch = currentEpochElement.value;
                    const currentIndex = availableEpocas.indexOf(currentEpoch);
                    if (currentIndex < availableEpocas.length - 1) {
                        labels.unshift('√âpoca Anterior');
                    }
                }
            }

            DebugUtils.debugEloChart('labels', labels);
            DebugUtils.debugEloChart('adjustments', hasAdjustments);

            checkboxes.forEach((checkbox, index) => {
                if (checkbox.checked && sampleData.teams[index]) {
                    const team = sampleData.teams[index];
                    const teamHistory = sampleData.eloHistory[team.name] || [1500];

                    DebugUtils.debugEloChart('team_added', { name: team.name, history: teamHistory });

                    // Duplicar o primeiro valor para criar o ponto "√âpoca Anterior" (s√≥ se houver √©poca anterior)
                    let dataToUse = teamHistory;
                    const currentEpochElement = document.getElementById('epoca');
                    if (currentEpochElement) {
                        const currentEpoch = currentEpochElement.value;
                        const currentIndex = availableEpocas.indexOf(currentEpoch);
                        if (currentIndex < availableEpocas.length - 1) {
                            dataToUse = [teamHistory[0], ...teamHistory];
                        }
                    }

                    datasets.push({
                        label: team.name,
                        data: dataToUse,
                        borderColor: team.color,
                        backgroundColor: team.color + '20',
                        fill: false,
                        borderWidth: 3,
                        tension: 0.3
                    });
                }
            });

            DebugUtils.debugEloChart('datasets_total', datasets.length);

            eloChart.data.labels = labels;
            eloChart.data.datasets = datasets;

            // Calcular min e max dos dados e adicionar padding de 5%
            if (datasets.length > 0) {
                let allValues = [];
                datasets.forEach(dataset => {
                    if (dataset.data) {
                        allValues = allValues.concat(dataset.data.filter(v => v !== null && v !== undefined));
                    }
                });

                if (allValues.length > 0) {
                    const minValue = Math.min(...allValues);
                    const maxValue = Math.max(...allValues);
                    const range = maxValue - minValue;
                    const padding = range * 0.05;

                    eloChart.options.scales.y.min = minValue - padding;
                    eloChart.options.scales.y.max = maxValue + padding;
                }
            }

            eloChart.update('active');

            // Atualizar labels din√¢micos ap√≥s o gr√°fico ser renderizado
            setTimeout(() => {
                updateDynamicTeamLabels();
            }, 100);
        }

        // Fun√ß√£o para criar e posicionar labels din√¢micos no final das linhas
        function updateDynamicTeamLabels() {
            const labelsContainer = document.getElementById('teamEndLabels');
            const chartInstance = eloChart;

            if (!chartInstance || !labelsContainer) return;

            labelsContainer.innerHTML = ''; // Limpar labels existentes

            // Obter apenas as equipas ativas (vis√≠veis no gr√°fico)
            const activeDatasets = chartInstance.data.datasets || [];
            const chartArea = chartInstance.chartArea;
            const canvas = chartInstance.canvas;
            const canvasRect = canvas.getBoundingClientRect();
            const containerRect = labelsContainer.getBoundingClientRect();

            // Calcular offset entre canvas e container
            const offsetX = canvasRect.left - containerRect.left;
            const offsetY = canvasRect.top - containerRect.top;

            // Coletar informa√ß√µes de todas as equipas primeiro
            const teamEndpoints = [];

            activeDatasets.forEach((dataset, datasetIndex) => {
                if (dataset && dataset.data && dataset.data.length > 0) {
                    // Em vez de procurar o √∫ltimo ponto absoluto, encontrar o √∫ltimo ponto VIS√çVEL
                    let rightmostVisibleIndex = -1;
                    let rightmostVisibleX = -Infinity;

                    // Percorrer todos os pontos para encontrar o mais √† direita que est√° vis√≠vel
                    for (let i = 0; i < dataset.data.length; i++) {
                        if (dataset.data[i] !== null && dataset.data[i] !== undefined) {
                            const xPixel = chartInstance.scales.x.getPixelForValue(i);

                            // Verificar se este ponto est√° na √°rea vis√≠vel do gr√°fico
                            if (xPixel >= chartArea.left && xPixel <= chartArea.right) {
                                if (xPixel > rightmostVisibleX) {
                                    rightmostVisibleX = xPixel;
                                    rightmostVisibleIndex = i;
                                }
                            }
                        }
                    }

                    // Se encontrou um ponto vis√≠vel, usar esse
                    if (rightmostVisibleIndex >= 0) {
                        const visibleValue = dataset.data[rightmostVisibleIndex];
                        const xPixel = chartInstance.scales.x.getPixelForValue(rightmostVisibleIndex);
                        const yPixel = chartInstance.scales.y.getPixelForValue(visibleValue);

                        // Verificar se o ponto Y tamb√©m est√° numa √°rea razo√°vel
                        if (yPixel >= chartArea.top - 50 && yPixel <= chartArea.bottom + 50) {
                            teamEndpoints.push({
                                dataset: dataset,
                                xPosition: xPixel,
                                yPixel: yPixel,
                                lastValue: visibleValue,
                                name: dataset.label,
                                dataIndex: rightmostVisibleIndex
                            });
                        }
                    }
                }
            });

            // Calcular n√≠vel de zoom atual para ajustar thresholds dinamicamente
            const yScale = chartInstance.scales.y;
            const xScale = chartInstance.scales.x;

            // Calcular fator de zoom baseado na diferen√ßa entre escalas atuais e originais
            const originalYRange = yScale.max - yScale.min;
            const originalXRange = xScale.max - xScale.min;

            // Estimar zoom baseado na altura vis√≠vel da escala Y
            const currentYRange = (eloChart.options.scales?.y?.max || yScale.max) -
                (eloChart.options.scales?.y?.min || yScale.min);
            const currentXRange = (eloChart.options.scales?.x?.max || xScale.max) -
                (eloChart.options.scales?.x?.min || xScale.min);

            const yZoomFactor = originalYRange / currentYRange;
            const xZoomFactor = originalXRange / currentXRange;
            const avgZoomFactor = (yZoomFactor + xZoomFactor) / 2;

            // Ajustar thresholds baseado no zoom - quanto maior o zoom, menor o threshold
            // Isso permite que labels se separem quando h√° zoom suficiente
            const baseProximityThreshold = 25;
            const baseEloThreshold = 15;

            // Reduzir thresholds com zoom para permitir separa√ß√£o de labels
            const proximityThreshold = Math.max(8, baseProximityThreshold / Math.sqrt(avgZoomFactor));
            const eloThreshold = Math.max(3, baseEloThreshold / Math.sqrt(avgZoomFactor));

            DebugUtils.debugVisualization('zoom_info', {
                zoom: avgZoomFactor.toFixed(2),
                proximity: proximityThreshold.toFixed(1),
                eloThreshold: eloThreshold.toFixed(1)
            });

            const processedTeams = new Set();
            const labelsToShow = [];

            teamEndpoints.forEach((team, index) => {
                if (processedTeams.has(index)) return;

                // Encontrar equipas pr√≥ximas
                const nearbyTeams = [team];
                const nearbyIndices = [index];

                teamEndpoints.forEach((otherTeam, otherIndex) => {
                    if (otherIndex === index || processedTeams.has(otherIndex)) return;

                    const verticalDistance = Math.abs(team.yPixel - otherTeam.yPixel);
                    const eloDistance = Math.abs(team.lastValue - otherTeam.lastValue);
                    const horizontalDistance = Math.abs(team.xPosition - otherTeam.xPosition);

                    // L√≥gica melhorada: equipas s√£o consideradas pr√≥ximas se:
                    // 1. Est√£o visualmente pr√≥ximas (pixels) E t√™m ELO similar
                    // 2. OU est√£o muito pr√≥ximas visualmente independente do ELO
                    const isVisuallyClose = verticalDistance < proximityThreshold;
                    const hasCloseELO = eloDistance < eloThreshold;
                    const isVeryClose = verticalDistance < (proximityThreshold / 2);

                    if ((isVisuallyClose && hasCloseELO) || isVeryClose) {
                        // Adicionar verifica√ß√£o de dist√¢ncia horizontal para evitar agrupar linhas muito distantes horizontalmente
                        if (horizontalDistance < 150) {
                            nearbyTeams.push(otherTeam);
                            nearbyIndices.push(otherIndex);
                        }
                    }
                });

                // Marcar todas as equipas pr√≥ximas como processadas
                nearbyIndices.forEach(idx => processedTeams.add(idx));

                if (nearbyTeams.length === 1) {
                    // Equipa isolada - mostrar normalmente
                    labelsToShow.push(team);
                } else {
                    // Com zoom alto suficiente, mostrar labels individuais
                    if (avgZoomFactor > 3) {
                        // Zoom alto - mostrar todas as equipas individualmente
                        nearbyTeams.forEach(nearbyTeam => {
                            labelsToShow.push(nearbyTeam);
                        });
                    } else {
                        // Zoom normal - agrupar equipas pr√≥ximas e mostrar apenas a com ELO mais alto
                        const highestEloTeam = nearbyTeams.reduce((highest, current) =>
                            current.lastValue > highest.lastValue ? current : highest
                        );

                        // Criar label combinado com informa√ß√£o de m√∫ltiplas equipas
                        const combinedTeam = {
                            ...highestEloTeam,
                            name: nearbyTeams.length > 3
                                ? `${highestEloTeam.name} (+${nearbyTeams.length - 1} outras)`
                                : nearbyTeams.map(t => t.name).join(', '),
                            isGroup: nearbyTeams.length > 1,
                            groupSize: nearbyTeams.length
                        };

                        labelsToShow.push(combinedTeam);
                    }
                }
            });

            // Criar os labels visuais para pontos relevantes
            labelsToShow.forEach((team, index) => {
                const label = document.createElement('div');
                label.className = 'team-end-label visible';
                if (team.isGroup) {
                    label.classList.add('group-label');
                }

                label.style.borderColor = team.dataset.borderColor;
                label.style.color = team.dataset.borderColor;

                // As coordenadas xPosition e yPixel j√° s√£o absolutas em rela√ß√£o ao canvas
                // Calcular posi√ß√£o diretamente sem subtra√ß√£o adicional
                let labelX = team.xPosition + 8; // Offset padr√£o de 8px √† direita do ponto
                let labelY = team.yPixel;

                // Se o ponto estiver fora da √°rea direita, colocar label na borda direita
                if (team.xPosition > chartArea.right) {
                    labelX = chartArea.right + 8; // Fixar logo ap√≥s a borda direita
                }

                // Com zoom alto, adicionar pequeno offset vertical para labels individuais muito pr√≥ximas
                if (avgZoomFactor > 3) {
                    // Verificar se h√° outras labels muito pr√≥ximas e ajustar posi√ß√£o
                    const otherLabels = labelsToShow.slice(0, index);
                    const conflictingLabels = otherLabels.filter(other => {
                        return Math.abs(labelY - other.yPixel) < 18 && Math.abs(labelX - (other.xPosition + 8)) < 60;
                    });

                    if (conflictingLabels.length > 0) {
                        labelY += conflictingLabels.length * 18; // Offset de 18px por cada label conflitante
                    }
                }

                // Garantir que a label fica dentro dos limites do canvas
                labelX = Math.max(chartArea.left + 8, Math.min(chartArea.right + 100, labelX));
                labelY = Math.max(chartArea.top, Math.min(chartArea.bottom - 20, labelY));

                // Posicionamento final com offset correto (coordenadas j√° s√£o absolutas)
                label.style.left = (offsetX + labelX) + 'px';
                label.style.top = (offsetY + labelY) + 'px';
                label.textContent = team.name;

                labelsContainer.appendChild(label);
            });

            // Adicionar bot√£o de √©poca anterior
            addPreviousSeasonButton();
        }

        // Fun√ß√£o para adicionar bot√£o de √©poca anterior
        function addPreviousSeasonButton() {
            const labelsContainer = document.getElementById('teamEndLabels');
            const chartInstance = eloChart;

            if (!chartInstance || !labelsContainer) return;

            const chartArea = chartInstance.chartArea;
            const canvas = chartInstance.canvas;
            const canvasRect = canvas.getBoundingClientRect();
            const containerRect = labelsContainer.getBoundingClientRect();

            const offsetX = canvasRect.left - containerRect.left;
            const offsetY = canvasRect.top - containerRect.top;

            // Remover bot√µes existentes
            const existingButtons = labelsContainer.querySelectorAll('.season-nav-btn');
            existingButtons.forEach(btn => btn.remove());

            // Obter √©poca atual
            const currentEpochElement = document.getElementById('epoca');
            if (!currentEpochElement) return;

            const currentEpoch = currentEpochElement.value;
            const currentIndex = availableEpocas.indexOf(currentEpoch);

            const yPosition = offsetY + chartArea.top - 40; // 40px acima do gr√°fico

            // Bot√£o √âpoca Anterior (s√≥ se houver √©poca anterior)
            if (currentIndex < availableEpocas.length - 1) {
                const previousEpoch = availableEpocas[currentIndex + 1];
                const btnPrev = document.createElement('button');
                btnPrev.className = 'season-nav-btn previous-season-btn';
                btnPrev.textContent = '‚Üê √âpoca Anterior';
                btnPrev.title = `Ver √©poca 20${previousEpoch.replace('_', '/')}`;

                // Posicionar √† esquerda
                btnPrev.style.left = (offsetX + chartArea.left) + 'px';
                btnPrev.style.top = yPosition + 'px';

                btnPrev.onclick = () => {
                    // Obter modalidade atual (sem a √©poca)
                    const modalidadeSelect = document.getElementById('modalidade');
                    const currentMod = modalidadeSelect.value.replace(`_${currentEpoch}`, '');

                    // Mudar √©poca
                    currentEpochElement.value = previousEpoch;
                    changeEpoca(previousEpoch);

                    // Selecionar a mesma modalidade na nova √©poca
                    setTimeout(() => {
                        const newModValue = `${currentMod}_${previousEpoch}`;
                        modalidadeSelect.value = newModValue;
                        changeModalidade(newModValue);
                    }, 100);
                };

                labelsContainer.appendChild(btnPrev);
            }

            // Bot√£o √âpoca Seguinte (s√≥ se houver √©poca seguinte)
            if (currentIndex > 0) {
                const nextEpoch = availableEpocas[currentIndex - 1];
                const btnNext = document.createElement('button');
                btnNext.className = 'season-nav-btn next-season-btn';
                btnNext.textContent = '√âpoca Seguinte ‚Üí';
                btnNext.title = `Ver √©poca 20${nextEpoch.replace('_', '/')}`;

                // Posicionar √† direita do gr√°fico
                btnNext.style.right = '20px'; // 20px da borda direita do container
                btnNext.style.top = yPosition + 'px';

                btnNext.onclick = () => {
                    // Obter modalidade atual (sem a √©poca)
                    const modalidadeSelect = document.getElementById('modalidade');
                    const currentMod = modalidadeSelect.value.replace(`_${currentEpoch}`, '');

                    // Mudar √©poca
                    currentEpochElement.value = nextEpoch;
                    changeEpoca(nextEpoch);

                    // Selecionar a mesma modalidade na nova √©poca
                    setTimeout(() => {
                        const newModValue = `${currentMod}_${nextEpoch}`;
                        modalidadeSelect.value = newModValue;
                        changeModalidade(newModValue);
                    }, 100);
                };

                labelsContainer.appendChild(btnNext);
            }
        }

        // Fun√ß√µes de controle de zoom
        function zoomChart(factor) {
            if (!eloChart) return;

            const chart = eloChart;
            const xScale = chart.scales.x;
            const yScale = chart.scales.y;

            // Calcular novos limites do zoom
            const xRange = xScale.max - xScale.min;
            const yRange = yScale.max - yScale.min;

            const newXRange = xRange / factor;
            const newYRange = yRange / factor;

            const xCenter = (xScale.max + xScale.min) / 2;
            const yCenter = (yScale.max + yScale.min) / 2;

            // Aplicar zoom
            chart.options.scales.x.min = xCenter - newXRange / 2;
            chart.options.scales.x.max = xCenter + newXRange / 2;
            chart.options.scales.y.min = yCenter - newYRange / 2;
            chart.options.scales.y.max = yCenter + newYRange / 2;

            chart.update('none');

            // Atualizar labels ap√≥s zoom
            setTimeout(() => {
                updateDynamicTeamLabels();
            }, 50);
        }

        function resetZoom() {
            if (!eloChart) return;

            // Remover limites personalizados
            delete eloChart.options.scales.x.min;
            delete eloChart.options.scales.x.max;
            delete eloChart.options.scales.y.min;
            delete eloChart.options.scales.y.max;

            eloChart.update('none');

            // Atualizar labels ap√≥s reset
            setTimeout(() => {
                updateDynamicTeamLabels();
            }, 50);
        }

        function togglePanMode() {
            if (window.toggleManualPan) {
                window.toggleManualPan();
            }
        }

        // Fun√ß√£o para obter ELO mais recente e posi√ß√£o no ranking geral
        function getTeamEloInfo(teamName) {
            const normalizedTeamName = normalizeTeamName(teamName);

            // Obter ELO mais recente
            const teamHistory = sampleData.eloHistory[normalizedTeamName];
            if (!teamHistory || teamHistory.length === 0) {
                return { elo: 1500, position: null };
            }

            const latestElo = Math.round(teamHistory[teamHistory.length - 1]);

            // Calcular ranking geral de ELO
            const allTeamsElo = [];
            Object.keys(sampleData.eloHistory).forEach(team => {
                const history = sampleData.eloHistory[team];
                if (history && history.length > 0) {
                    const currentElo = history[history.length - 1];
                    allTeamsElo.push({ team, elo: currentElo });
                }
            });

            // Ordenar por ELO (maior para menor)
            allTeamsElo.sort((a, b) => b.elo - a.elo);

            // Encontrar posi√ß√£o da equipa
            const position = allTeamsElo.findIndex(entry => entry.team === normalizedTeamName) + 1;

            return { elo: latestElo, position: position > 0 ? position : null };
        }

        // Atualizar tabela de classifica√ß√µes
        function updateRankingsTable() {
            const tbody = document.getElementById('rankingsBody');
            const progressionLegend = document.getElementById('progressionLegend');

            if (!sampleData.rankings || Object.keys(sampleData.rankings).length === 0) {
                tbody.innerHTML = '<tr><td colspan="11" style="text-align: center; color: #666;">Nenhum dado dispon√≠vel</td></tr>';
                progressionLegend.style.display = 'none';
                return;
            }

            // Usar a primeira divis√£o dispon√≠vel se currentDivision n√£o existir
            if (!sampleData.rankings[currentDivision]) {
                currentDivision = Object.keys(sampleData.rankings)[0];
            }

            let teams = sampleData.rankings[currentDivision] || [];

            // Filtrar por grupo se houver sele√ß√£o de grupo
            if (currentGroup !== null) {
                teams = teams.filter(team => team.group === currentGroup);
            }

            // Analisar estrutura da modalidade para determinar progress√µes
            const structure = analyzeModalityStructure();
            const totalTeams = teams.length;

            // Mostrar legenda se houver equipes suficientes para progress√µes
            const showProgressionIndicators = totalTeams >= 4;

            // Atualizar legenda din√¢mica
            updateProgressionLegend(showProgressionIndicators, structure);

            tbody.innerHTML = '';

            teams.forEach((team, index) => {
                const position = index + 1;
                const row = document.createElement('tr');
                const goalDiff = (team.goals || 0) - (team.conceded || 0);
                const goalDiffText = goalDiff > 0 ? `+${goalDiff}` : goalDiff.toString();
                const totalGames = (team.wins || 0) + (team.draws || 0) + (team.losses || 0);

                // Determinar progress√£o no torneio - AGORA passa o nome da equipa para verificar se √© B
                const progression = showProgressionIndicators ?
                    getTeamProgression(position, totalTeams, structure, team.team, currentGroup) :
                    { type: 'safe', description: 'Zona segura' };

                // Obter informa√ß√µes do curso para emblema - aplicar normaliza√ß√£o
                const normalizedTeamName = normalizeTeamName(team.team);
                const courseInfo = getCourseInfo(normalizedTeamName);
                const emblemHtml = courseInfo.emblemPath ?
                    `<img src="${courseInfo.emblemPath}" alt="${normalizedTeamName}" class="team-emblem-table" onerror="this.style.display='none'">` :
                    '';

                // Criar indicador de progress√£o
                const progressionClass = showProgressionIndicators ? `progression-${progression.type}` : 'progression-safe';
                const badgeTitle = showProgressionIndicators ? progression.description : `${position}¬∫ lugar`;

                // Obter informa√ß√£o do ELO - aplicar normaliza√ß√£o
                const eloInfo = getTeamEloInfo(normalizedTeamName);
                const eloDisplay = eloInfo.position ? `${eloInfo.elo} (#${eloInfo.position})` : `${eloInfo.elo}`;

                row.innerHTML = `
                    <td>
                        <span class="rank-badge ${progressionClass}" title="${badgeTitle}">${position}</span>
                    </td>
                    <td class="team-cell">
                        ${emblemHtml}
                        <div class="team-color-indicator" style="background-color: ${courseInfo.primaryColor}"></div>
                        <div class="team-info-container">
                            <span class="team-name-table" title="${courseInfo.fullName}">${normalizedTeamName}</span>
                            <span class="team-elo-info" title="ELO atual e posi√ß√£o no ranking geral">${eloDisplay}</span>
                        </div>
                    </td>
                    <td><strong>${team.points}</strong></td>
                    <td>${totalGames}</td>
                    <td>${team.wins || 0}</td>
                    <td>${team.draws || 0}</td>
                    <td>${team.losses || 0}</td>
                    <td style="color: red;">${team.noShows || 0}</td>
                    <td>${team.goals || 0}</td>
                    <td>${team.conceded || 0}</td>
                    <td style="color: ${goalDiff > 0 ? '#28a745' : goalDiff < 0 ? '#dc3545' : '#666'}">${goalDiffText}</td>
                `;
                tbody.appendChild(row);
            });
        }

        /**
         * Atualiza a legenda de progress√£o dinamicamente baseada no contexto
         */
        function updateProgressionLegend(show, structure) {
            const progressionLegend = document.getElementById('progressionLegend');

            if (!show) {
                progressionLegend.style.display = 'none';
                return;
            }

            progressionLegend.style.display = 'flex';

            // Determinar quais legendas mostrar baseado no contexto
            const legendItems = [];
            const divisionNum = parseInt(currentDivision) || 1;
            const isSecondDivision = divisionNum === 2;

            // Detectar se h√° sistema de playoff/liguilha
            const hasWinnerPlayoffs = playoffSystemInfo.hasWinnerPlayoffs || false;
            const hasMaintenancePlayoffs = playoffSystemInfo.hasMaintenancePlayoffs || false;
            const hasMaintenanceLeague = playoffSystemInfo.hasMaintenanceLeague || false;

            // √âpoca atual para determinar compatibilidade
            const is25_26 = currentEpoca === '25_26';

            // Legendas para 1¬™ divis√£o
            if (divisionNum === 1) {
                // Play-offs para o vencedor (sempre 8 equipas)
                legendItems.push({
                    badge: 'P',
                    cssClass: 'legend-playoffs',
                    text: 'Play-offs'
                });

                // Playoff/Liguilha de manuten√ß√£o - S√ì mostrar se realmente existir
                if (hasMaintenancePlayoffs) {
                    legendItems.push({
                        badge: 'PM',
                        cssClass: 'legend-maintenance-playoffs',
                        text: 'Play-off de Manuten√ß√£o'
                    });
                } else if (hasMaintenanceLeague) {
                    legendItems.push({
                        badge: 'LM',
                        cssClass: 'legend-maintenance-league',
                        text: 'Liguilha de Manuten√ß√£o'
                    });
                }

                // Sempre mostrar descida direta (√∫ltimos 2 ou 3 dependendo de haver PM/LM)
                legendItems.push({
                    badge: '‚Üì',
                    cssClass: 'legend-relegation',
                    text: 'Descida de divis√£o'
                });
            }
            // Legendas para 2¬™ divis√£o
            else if (isSecondDivision) {
                // 1¬∫ de cada grupo vai aos playoffs + promo√ß√£o
                legendItems.push({
                    badge: 'P',
                    cssClass: 'legend-playoffs',
                    text: 'Play-offs + Promo√ß√£o'
                });

                // 2¬∫ lugar: depende se h√° PM/LM ou n√£o
                if (hasMaintenancePlayoffs) {
                    legendItems.push({
                        badge: 'PP',
                        cssClass: 'legend-promotion-playoffs',
                        text: 'Play-off de Promo√ß√£o'
                    });
                } else if (hasMaintenanceLeague) {
                    legendItems.push({
                        badge: 'LP',
                        cssClass: 'legend-promotion-league',
                        text: 'Liguilha de Promo√ß√£o'
                    });
                } else {
                    // Sem PM/LM: 2¬∫ sobe direto
                    legendItems.push({
                        badge: '‚Üë',
                        cssClass: 'legend-promotion',
                        text: 'Subida de divis√£o'
                    });
                }
            }
            // Legendas para 3¬™+ divis√£o
            else {
                legendItems.push({
                    badge: '‚Üë',
                    cssClass: 'legend-promotion',
                    text: 'Subida de divis√£o'
                });
            }

            // Sempre adicionar zona segura
            legendItems.push({
                badge: 'S',
                cssClass: 'legend-safe',
                text: 'Zona segura'
            });

            // Gerar HTML da legenda
            progressionLegend.innerHTML = legendItems.map(item => `
                <div class="legend-item">
                    <div class="legend-badge ${item.cssClass}">${item.badge}</div>
                    <span>${item.text}</span>
                </div>
            `).join('');
        }

        // Cache para equipas qualificadas
        let qualifiedTeamsCache = null;

        // Obter equipas qualificadas baseado na classifica√ß√£o
        function getQualifiedTeams(forceRefresh = false) {
            // Usar cache se dispon√≠vel e n√£o for for√ßado refresh
            if (qualifiedTeamsCache && !forceRefresh) {
                return qualifiedTeamsCache;
            }
            const structure = analyzeModalityStructure();
            const qualified = {
                playoffs: [],           // Top 8 para playoffs principais
                maintenancePlayoff: [], // Equipas para PM
                promotionPlayoff: [],   // Equipas para PP (2¬™ divis√£o)
                legend: []              // Legenda dos lugares
            };

            DebugUtils.debugBracket('qualified_teams', {
                rankingsAvailable: sampleData.rankings ? Object.keys(sampleData.rankings) : [],
                structure: structure
            });

            DebugUtils.debugQualification('structure_detected', structure);
            DebugUtils.debugQualification('rankings_keys', Object.keys(sampleData.rankings));

            if (!sampleData.rankings || Object.keys(sampleData.rankings).length === 0) {
                console.warn('‚ö†Ô∏è getQualifiedTeams: rankings n√£o dispon√≠veis ainda');
                return qualified;
            }

            // Liga √∫nica - top 8 v√£o para playoffs
            if (structure.type === 'single-league') {
                const ranking = sampleData.rankings['geral'] || [];

                // Os rankings j√° v√™m ordenados do CSV, mas garantir ordena√ß√£o por pontos
                ranking.sort((a, b) => {
                    if (b.points !== a.points) return b.points - a.points;
                    const diffA = (a.goals || 0) - (a.conceded || 0);
                    const diffB = (b.goals || 0) - (b.conceded || 0);
                    return diffB - diffA;
                });

                qualified.playoffs = ranking.slice(0, 8).map(team => team.team);

                DebugUtils.debugQualification('single_league_playoffs', qualified.playoffs);

                // Criar legenda
                for (let i = 0; i < Math.min(8, ranking.length); i++) {
                    qualified.legend.push({
                        position: i + 1,
                        team: ranking[i].team,
                        type: 'playoff'
                    });
                }
                return qualified;
            }

            // Sistema com divis√µes
            if (structure.hasDivisions) {
                DebugUtils.debugQualification('has_divisions');
                const div1Teams = [];
                const div2Teams = [];

                DebugUtils.debugQualification('available_keys', Object.keys(sampleData.rankings));

                // Processar cada divis√£o - busca flex√≠vel por padr√µes
                Object.entries(sampleData.rankings).forEach(([key, ranking]) => {
                    DebugUtils.debugQualification('processing_key', { key, count: ranking.length });

                    // Buscar 1¬™ divis√£o
                    const is1stDiv = key.includes('1¬™ Divis√£o') ||
                        key === '1' ||
                        key.match(/1[¬™a]\s*div/i);

                    if (is1stDiv) {
                        DebugUtils.debugQualification('match_1st_division', ranking.length);
                        div1Teams.push(...ranking);
                    }
                    // Buscar 2¬™ divis√£o - QUALQUER grupo
                    else {
                        const is2ndDiv = key.includes('2¬™ Divis√£o') ||
                            key === '2' ||
                            key.match(/2[¬™a]\s*div/i);

                        if (is2ndDiv) {
                            DebugUtils.debugQualification('match_2nd_division', ranking.length);
                            div2Teams.push(...ranking);
                        } else {
                            DebugUtils.debugQualification('no_match', key);
                        }
                    }
                });

                // Ordenar por pontos (n√£o por ELO que pode n√£o existir ainda)
                div1Teams.sort((a, b) => {
                    if (b.points !== a.points) return b.points - a.points;
                    // Desempate por diferen√ßa de golos
                    const diffA = (a.goals || 0) - (a.conceded || 0);
                    const diffB = (b.goals || 0) - (b.conceded || 0);
                    return diffB - diffA;
                });

                div2Teams.sort((a, b) => {
                    if (b.points !== a.points) return b.points - a.points;
                    const diffA = (a.goals || 0) - (a.conceded || 0);
                    const diffB = (b.goals || 0) - (b.conceded || 0);
                    return diffB - diffA;
                });

                DebugUtils.debugQualification('teams_sorted', { div1: div1Teams.map(t => `${t.team} (${t.points}pts)`), div2: div2Teams.map(t => `${t.team} (${t.points}pts)`) });

                // Determinar n√∫mero de equipas para playoffs baseado na estrutura
                // Contar APENAS grupos da 2¬™ divis√£o
                const numGroups2ndDiv = Object.keys(sampleData.rankings).filter(key =>
                    key.match(/^2[¬™a]?\s*(div|divis√£o|divisao)?\s*-?\s*grupo/i)
                ).length;

                // Se h√° 2¬™ divis√£o mas sem grupos, assume 1 equipa da 2¬™ divis√£o (7 da 1¬™ + 1 da 2¬™ = 8)
                // Se h√° grupos, cada grupo manda 1 equipa (ex: 2 grupos = 6 da 1¬™ + 2 da 2¬™ = 8)
                // Se n√£o h√° 2¬™ divis√£o, todas as 8 vagas s√£o da 1¬™
                const playoffSlots1stDiv = div2Teams.length > 0
                    ? (numGroups2ndDiv > 0 ? Math.max(0, 8 - numGroups2ndDiv) : 7)
                    : 8;

                DebugUtils.debugQualification('playoff_slots', {
                    first: playoffSlots1stDiv,
                    second: div2Teams.length > 0 ? (numGroups2ndDiv || 1) : 0,
                    total: 8,
                    hasGroups: numGroups2ndDiv > 0
                });

                // Top da 1¬™ divis√£o v√£o para playoffs (excluindo equipas B)
                if (playoffSlots1stDiv > 0 && div1Teams.length > 0) {
                    let qualifiedCount = 0;
                    let currentPos = 0;
                    let skippedBTeams = 0;

                    DebugUtils.debugQualification('selecting_1st_division');

                    while (qualifiedCount < playoffSlots1stDiv && currentPos < div1Teams.length) {
                        const team = div1Teams[currentPos];

                        if (TeamUtils.isTeamB(team.team)) {
                            DebugUtils.debugQualification('team_b_skip', { position: currentPos + 1, team: team.team });
                            skippedBTeams++;
                            currentPos++;
                            continue;
                        }

                        DebugUtils.debugQualification('team_qualified', { position: currentPos + 1, team: team.team });
                        qualified.playoffs.push(team.team);
                        qualified.legend.push({
                            position: currentPos + 1,
                            team: team.team,
                            type: 'playoff',
                            division: '1¬™',
                            isSubstitute: skippedBTeams > 0 && qualifiedCount >= (currentPos + 1 - skippedBTeams)
                        });

                        qualifiedCount++;
                        currentPos++;
                    }

                    if (qualifiedCount < playoffSlots1stDiv) {
                        console.warn(`‚ö†Ô∏è Apenas ${qualifiedCount} de ${playoffSlots1stDiv} equipas qualificadas da 1¬™ divis√£o`);
                    }
                }

                // 1¬∫ da 2¬™ divis√£o vai para playoffs
                // Caso 1: Se h√° grupos na 2¬™ divis√£o, pegar 1¬∫ de cada grupo
                // Caso 2: Se n√£o h√° grupos mas h√° 2¬™ divis√£o, pegar 1¬∫ da 2¬™ divis√£o

                if (numGroups2ndDiv > 0) {
                    // CASO 1: 2¬™ divis√£o com grupos - 1¬∫ de cada grupo
                    const groups2ndDiv = {};
                    Object.entries(sampleData.rankings).forEach(([key, ranking]) => {
                        // Busca flex√≠vel por 2¬™ divis√£o COM GRUPO
                        if (key.match(/^2[¬™a]?\s*(div|divis√£o|divisao)?\s*-?\s*grupo\s+([A-Z])/i)) {
                            const groupMatch = key.match(/grupo\s+([A-Z])/i);
                            if (groupMatch && ranking.length > 0) {
                                const group = groupMatch[1].toUpperCase();

                                // Encontrar primeiro n√£o-B
                                let teamIndex = 0;
                                while (teamIndex < ranking.length && TeamUtils.isTeamB(ranking[teamIndex].team)) {
                                    DebugUtils.debugQualification('group_team_b_skip', { group, position: teamIndex + 1, team: ranking[teamIndex].team });
                                    teamIndex++;
                                }

                                if (teamIndex < ranking.length) {
                                    groups2ndDiv[group] = {
                                        team: ranking[teamIndex],
                                        actualPosition: teamIndex + 1,  // Posi√ß√£o real da equipa substituta
                                        placeholderPosition: 1          // SEMPRE usa 1¬∫ para o placeholder!
                                    };
                                    DebugUtils.debugQualification('group_winner', { group, team: ranking[teamIndex].team, position: teamIndex + 1 });
                                    if (teamIndex > 0) {
                                        DebugUtils.debugQualification('group_winner', { group, team: ranking[teamIndex].team, position: teamIndex + 1, replaces: ranking[0].team });
                                    }
                                } else {
                                    console.warn(`  ‚ö†Ô∏è Grupo ${group}: Todas as equipas s√£o B!`);
                                }
                            }
                        }
                    });

                    Object.entries(groups2ndDiv).forEach(([group, data]) => {
                        qualified.playoffs.push(data.team.team);
                        qualified.legend.push({
                            position: data.placeholderPosition,  // USA 1 para o placeholder
                            actualPosition: data.actualPosition,  // Guarda posi√ß√£o real para exibi√ß√£o
                            team: data.team.team,
                            type: 'playoff',
                            division: '2¬™',
                            group: isNaN(group) ? group : undefined,
                            isSubstitute: data.actualPosition > 1  // Flag indicando que √© substituto
                        });
                    });
                } else if (div2Teams.length > 0) {
                    // CASO 2: 2¬™ divis√£o SEM grupos - pegar 1¬∫ classificado geral (excluindo equipa B)
                    DebugUtils.debugQualification('selecting_2nd_division_no_groups');

                    let teamIndex = 0;
                    while (teamIndex < div2Teams.length && TeamUtils.isTeamB(div2Teams[teamIndex].team)) {
                        DebugUtils.debugQualification('team_b_skip_2nd_div', { position: teamIndex + 1, team: div2Teams[teamIndex].team });
                        teamIndex++;
                    }

                    if (teamIndex < div2Teams.length) {
                        const selectedTeam = div2Teams[teamIndex];
                        qualified.playoffs.push(selectedTeam.team);
                        qualified.legend.push({
                            position: teamIndex + 1,
                            actualPosition: teamIndex + 1,
                            team: selectedTeam.team,
                            type: 'playoff',
                            division: '2¬™',
                            isSubstitute: teamIndex > 0  // Flag se n√£o √© o 1¬∫ real
                        });
                        DebugUtils.debugQualification('2nd_div_winner', { team: selectedTeam.team, position: teamIndex + 1 });
                    } else {
                        console.warn(`  ‚ö†Ô∏è 2¬™ Divis√£o: Todas as equipas s√£o B!`);
                    }
                }

                // Equipas para playoff/liguilha de manuten√ß√£o ou promo√ß√£o
                if (playoffSystemInfo.hasMaintenancePlayoffs || playoffSystemInfo.hasMaintenanceLeague) {
                    // 5¬∫ pior da 1¬™ divis√£o (pen√∫ltimo = 9¬∫ lugar em 12 equipas) para playoff de manuten√ß√£o
                    const worstPos = div1Teams.length - 4; // 5¬∫ pior (√≠ndice 8 = 9¬∫ lugar)
                    if (worstPos >= 0 && worstPos < div1Teams.length) {
                        qualified.maintenancePlayoff.push(div1Teams[worstPos].team);
                        qualified.legend.push({
                            position: worstPos + 1,
                            team: div1Teams[worstPos].team,
                            type: playoffSystemInfo.hasMaintenancePlayoffs ? 'maintenance-playoff' : 'maintenance-league',
                            division: '1¬™'
                        });
                    }

                    // 2¬∫ de cada grupo da 2¬™ divis√£o v√£o para PP/LP (excluindo equipas B, a menos que equipa A esteja em descida)
                    DebugUtils.debugQualification('selecting_2nd_places');
                    Object.entries(sampleData.rankings).forEach(([key, ranking]) => {
                        // Busca flex√≠vel por 2¬™ divis√£o COM GRUPO
                        if (key.match(/^2[¬™a]?\s*(div|divis√£o|divisao)?\s*-?\s*grupo\s+([A-Z])/i) && ranking.length > 1) {
                            const groupMatch = key.match(/grupo\s+([A-Z])/i);
                            if (groupMatch) {
                                const group = groupMatch[1].toUpperCase();

                                // Encontrar equipa eleg√≠vel (n√£o-B, n√£o j√° qualificada para playoffs, ou B com A em descida)
                                let teamIndex = 1; // Come√ßar do 2¬∫ lugar
                                let selectedTeam = null;
                                let selectedPosition = null;

                                while (teamIndex < ranking.length && !selectedTeam) {
                                    const team = ranking[teamIndex];

                                    // ‚ö†Ô∏è VERIFICAR SE J√Å FOI PARA PLAYOFFS DE VENCEDORES
                                    if (qualified.playoffs.includes(team.team)) {
                                        DebugUtils.debugQualification('already_in_playoffs', { group, position: teamIndex + 1, team: team.team });
                                        teamIndex++;
                                        continue;
                                    }

                                    if (TeamUtils.isTeamB(team.team)) {
                                        // Verificar se equipa A est√° em descida
                                        if (TeamUtils.isTeamAInRelegation(team.team, div1Teams)) {
                                            DebugUtils.debugQualification('team_b_with_relegation', { group, position: teamIndex + 1, team: team.team });
                                            selectedTeam = team;
                                            selectedPosition = teamIndex + 1;
                                        } else {
                                            DebugUtils.debugQualification('team_b_no_relegation', { group, position: teamIndex + 1, team: team.team });
                                            teamIndex++;
                                        }
                                    } else {
                                        DebugUtils.debugQualification('team_qualified', { position: teamIndex + 1, team: team.team });
                                        selectedTeam = team;
                                        selectedPosition = teamIndex + 1;
                                    }
                                }

                                if (selectedTeam) {
                                    qualified.promotionPlayoff.push(selectedTeam.team);
                                    qualified.legend.push({
                                        position: 2,  // SEMPRE usa 2¬∫ para o placeholder
                                        actualPosition: selectedPosition,  // Posi√ß√£o real
                                        team: selectedTeam.team,
                                        type: playoffSystemInfo.hasMaintenancePlayoffs ? 'promotion-playoff' : 'promotion-league',
                                        division: '2¬™',
                                        group: group,
                                        isSubstitute: selectedPosition > 2  // Flag se n√£o √© o 2¬∫ real
                                    });
                                } else {
                                    console.warn(`  ‚ö†Ô∏è Grupo ${group}: Nenhuma equipa eleg√≠vel encontrada!`);
                                }
                            }
                        }
                    });
                }
            }

            DebugUtils.debugBracket('qualified_teams_result', {
                playoffs: qualified.playoffs,
                maintenancePlayoff: qualified.maintenancePlayoff,
                promotionPlayoff: qualified.promotionPlayoff,
                legendCount: qualified.legend.length
            });

            DebugUtils.debugQualification('qualified_complete', qualified.legend);

            // Cachear resultado
            qualifiedTeamsCache = qualified;

            return qualified;
        }

        // Fun√ß√£o global para resolver nomes de equipas (substituir placeholders)
        function resolveTeamName(teamName) {
            // Obter mapa de substitui√ß√µes atual
            const qualified = getQualifiedTeams();
            const qualifiedMap = {};

            DebugUtils.debugTeamResolution('resolving_team', teamName);
            DebugUtils.debugTeamResolution('qualified_legend', qualified.legend);

            // Criar mapa de placeholders para equipas reais
            qualified.legend.forEach(item => {
                let placeholder = '';
                DebugUtils.debugTeamResolution('legend_item', item);
                // Se n√£o tem divis√£o (single-league), criar mapeamento dos placeholders hardcoded no CSV
                if (!item.division) {
                    placeholder = `${item.position}¬∫ Class. 1¬™ Div.`;
                } else if (item.division === '1¬™') {
                    placeholder = `${item.position}¬∫ Class. 1¬™ Div.`;
                } else if (item.division === '2¬™') {
                    if (item.group) {
                        // ‚úÖ CORRIGIDO: Criar placeholders para AMBOS os formatos (com e sem "Gr.")
                        // Formato 1: "2¬∫ Class. 2¬™ Div. Gr. A" (usado em PM 25_26)
                        const placeholderWithGr = `${item.position}¬∫ Class. 2¬™ Div. Gr. ${item.group}`;
                        qualifiedMap[placeholderWithGr] = item.team;

                        // Formato 2: "2¬∫ Class. 2¬™ Div. A" (usado em LM 24_25)
                        const placeholderNoGr = `${item.position}¬∫ Class. 2¬™ Div. ${item.group}`;
                        qualifiedMap[placeholderNoGr] = item.team;

                        DebugUtils.debugTeamResolution('creating_placeholders_with_group', { withGr: placeholderWithGr, noGr: placeholderNoGr, team: item.team });
                        placeholder = null; // N√£o criar novamente abaixo
                    } else {
                        placeholder = `${item.position}¬∫ Class. 2¬™ Div.`;
                    }
                }
                // S√≥ criar placeholder se n√£o foi criado acima
                if (placeholder) {
                    DebugUtils.debugTeamResolution('creating_placeholder', { placeholder, team: item.team });
                    qualifiedMap[placeholder] = item.team;
                }
            });

            DebugUtils.debugTeamResolution('complete_map', qualifiedMap);

            // Se for placeholder, substituir
            if (qualifiedMap[teamName]) {
                DebugUtils.debugTeamResolution('resolved', { from: teamName, to: qualifiedMap[teamName] });
                return qualifiedMap[teamName];
            }
            DebugUtils.debugTeamResolution('not_found', teamName);
            return teamName;
        }

        // Criar bracket de dados reais dos CSVs
        function createRealBracket() {
            // Carregar dados originais do CSV diretamente para detectar "?"
            const modalidade = document.getElementById('modalidade').value;
            if (!modalidade) {
                sampleData.bracket = {};
                createBracket();
                return;
            }

            const jogosPath = `csv_modalidades/${modalidade}.csv`;

            Papa.parse(jogosPath, {
                download: true,
                header: true,
                complete: results => {
                    // Calcular n√∫mero m√°ximo de jornadas do calend√°rio (antes dos jogos acontecerem)
                    const regularRounds = results.data
                        .filter(match => match.Jornada && !isNaN(parseInt(match.Jornada)))
                        .map(match => parseInt(match.Jornada));

                    sampleData.totalRegularSeasonGames = regularRounds.length > 0 ? Math.max(...regularRounds) : 0;

                    // Filtrar jogos de elimina√ß√£o dos dados originais (E*)
                    const eliminationMatches = results.data.filter(match =>
                        match.Jornada && (
                            match.Jornada.startsWith('E1') ||  // Quartos
                            match.Jornada.startsWith('E2') ||  // Meias
                            match.Jornada.startsWith('E3')    // Final/3¬∫ lugar
                        )
                    );

                    // Filtrar jogos secund√°rios (PM* ou LM*)
                    const secondaryMatches = results.data.filter(match =>
                        match.Jornada && (
                            match.Jornada.startsWith('PM') ||  // Playoff Manuten√ß√£o/Promo√ß√£o
                            match.Jornada.startsWith('LM')     // Liguilha Manuten√ß√£o/Promo√ß√£o
                        )
                    );

                    if (eliminationMatches.length === 0) {
                        DebugUtils.debugBracket('no_elimination_games');
                        sampleData.bracket = {};
                        createBracket();
                    } else {
                        DebugUtils.debugBracket('elimination_games_found', eliminationMatches);
                        processEliminationMatches(eliminationMatches);
                    }

                    // Processar bracket secund√°rio se houver
                    if (secondaryMatches.length > 0) {
                        DebugUtils.debugBracket('secondary_games_found', secondaryMatches);
                        processSecondaryMatches(secondaryMatches);
                    } else {
                        sampleData.secondaryBracket = {};
                        createSecondaryBracket();
                    }
                },
                error: error => {
                    console.error('Erro ao carregar CSV para bracket:', error);
                    // Fallback para dados processados se houver erro
                    fallbackToProcessedData();
                }
            });
        }

        function fallbackToProcessedData() {
            if (!sampleData.rawEloData || sampleData.rawEloData.length === 0) {
                DebugUtils.debugBracket('no_elo_data');
                sampleData.bracket = {};
                createBracket();
                return;
            }

            const eliminationMatches = sampleData.rawEloData.filter(match =>
                match.Jornada && (
                    match.Jornada.startsWith('E1') ||
                    match.Jornada.startsWith('E2') ||
                    match.Jornada.startsWith('E3')
                )
            );

            processEliminationMatches(eliminationMatches, true);
        }

        function processEliminationMatches(eliminationMatches, isProcessedData = false) {
            DebugUtils.debugEliminationGames('processing_start', eliminationMatches.length);
            if (eliminationMatches.length > 0) {
                DebugUtils.debugEliminationGames('first_game', { game: eliminationMatches[0], team1: eliminationMatches[0]['Equipa 1'], team2: eliminationMatches[0]['Equipa 2'] });
            }

            if (eliminationMatches.length === 0) {
                DebugUtils.debugBracket('no_elimination_games');

                // Preencher bracket automaticamente com equipas qualificadas
                const qualified = getQualifiedTeams();

                // Criar bracket se houver equipas qualificadas suficientes (mesmo sem pontos)
                const canCreateBracket = qualified.playoffs.length >= 8 && sampleData.rankings;

                if (canCreateBracket) {
                    // Criar placeholders a partir do legend (em vez de usar nomes reais)
                    const playoffPlaceholders = qualified.legend
                        .filter(item => item.type === 'playoff')
                        .sort((a, b) => {
                            // Ordenar: 1¬™ divis√£o primeiro, depois 2¬™ divis√£o
                            if (a.division !== b.division) return a.division === '1¬™' ? -1 : 1;
                            // Dentro da divis√£o, ordenar por posi√ß√£o
                            if (a.position !== b.position) return a.position - b.position;
                            // Se mesmo grupo, ordenar alfabeticamente
                            if (a.group && b.group) return a.group.localeCompare(b.group);
                            return 0;
                        })
                        .map(item => {
                            // Se n√£o tem divis√£o definida (single-league), usar nome direto
                            if (!item.division || item.division === 'geral') {
                                return item.team;
                            }
                            // Se tem divis√£o, criar placeholder
                            if (item.division === '1¬™') {
                                return `${item.position}¬∫ Class. 1¬™ Div.`;
                            } else if (item.group) {
                                return `${item.position}¬∫ Class. 2¬™ Div. Gr. ${item.group}`;
                            } else {
                                return `${item.position}¬∫ Class. 2¬™ Div.`;
                            }
                        });

                    DebugUtils.debugEliminationGames('placeholders_created', playoffPlaceholders);
                    DebugUtils.debugBracket('auto_filling_bracket', playoffPlaceholders);
                    sampleData.bracket = createPredictedBracket(playoffPlaceholders);
                } else {
                    DebugUtils.debugEliminationGames('insufficient_teams');
                    sampleData.bracket = {};
                }

                createBracket();
                return;
            }

            DebugUtils.debugBracket('elimination_games_found', eliminationMatches);

            // Organizar jogos por fase na ordem de exibi√ß√£o correta
            const bracketData = {};

            // Obter equipas qualificadas para substituir placeholders
            const qualified = getQualifiedTeams();
            const qualifiedMap = {};

            // Criar mapa de placeholders para equipas reais
            qualified.legend.forEach(item => {
                let placeholder = '';
                // Se n√£o tem divis√£o (single-league), criar mapeamento dos placeholders hardcoded no CSV
                if (!item.division) {
                    placeholder = `${item.position}¬∫ Class. 1¬™ Div.`;
                } else if (item.division === '1¬™') {
                    placeholder = `${item.position}¬∫ Class. 1¬™ Div.`;
                } else if (item.division === '2¬™') {
                    if (item.group) {
                        placeholder = `${item.position}¬∫ Class. 2¬™ Div. Gr. ${item.group}`;
                    } else {
                        placeholder = `${item.position}¬∫ Class. 2¬™ Div.`;
                    }
                }
                if (placeholder) {
                    qualifiedMap[placeholder] = item.team;
                }
            });

            DebugUtils.debugEliminationGames('substitution_map', qualifiedMap);

            // Fun√ß√£o para substituir placeholder por equipa real
            function resolveTeamName(teamName) {
                // Se for placeholder, substituir
                if (qualifiedMap[teamName]) {
                    DebugUtils.debugEliminationGames('substituting', { from: teamName, to: qualifiedMap[teamName] });
                    return qualifiedMap[teamName];
                }
                return teamName;
            }

            // Fun√ß√£o auxiliar para detectar "?" nos dados originais ou processados
            function detectUnknownResult(match) {
                const allKeys = Object.keys(match);

                // Verificar todas as chaves poss√≠veis para encontrar "?"
                for (let key of allKeys) {
                    const value = match[key];
                    if (value && value.toString().trim() === '?') {
                        return true;
                    }
                }
                return false;
            }

            // Quartos de Final (E1)
            const quartos = eliminationMatches.filter(m =>
                (m.Jornada || m.round) &&
                (m.Jornada?.startsWith('E1') || m.round?.startsWith('E1')) &&
                !(m.Jornada?.includes('L') || m.round?.includes('L'))
            );
            if (quartos.length > 0) {
                DebugUtils.debugEliminationGames('quarters_info', { count: quartos.length, first: quartos[0] });
                bracketData["Quartos de Final"] = quartos.map(match => {
                    const isUnknownResult = detectUnknownResult(match);
                    DebugUtils.debugEliminationGames('before_resolve', { team1: match['Equipa 1'], team2: match['Equipa 2'] });
                    const team1 = resolveTeamName(match['Equipa 1']);
                    const team2 = resolveTeamName(match['Equipa 2']);
                    DebugUtils.debugEliminationGames('after_resolve', { team1, team2 });
                    // ‚ö†Ô∏è IMPORTANTE: Se score estiver vazio no CSV, usar null (n√£o 0)
                    const score1Val = match['Golos 1'] ? parseFloat(match['Golos 1']) : null;
                    const score2Val = match['Golos 2'] ? parseFloat(match['Golos 2']) : null;

                    // Procurar dados de ELO no rawEloData (mesmo padr√£o do calend√°rio)
                    const eloMatch = sampleData.rawEloData ? sampleData.rawEloData.find(m =>
                        m.Jornada === match.Jornada &&
                        normalizeTeamName(m['Equipa 1']) === normalizeTeamName(team1) &&
                        normalizeTeamName(m['Equipa 2']) === normalizeTeamName(team2)
                    ) : null;

                    const elo1Delta = eloMatch && eloMatch['Elo Delta 1'] ? parseInt(eloMatch['Elo Delta 1']) : 0;
                    const elo2Delta = eloMatch && eloMatch['Elo Delta 2'] ? parseInt(eloMatch['Elo Delta 2']) : 0;

                    return {
                        team1: team1,
                        team2: team2,
                        score1: score1Val,
                        score2: score2Val,
                        winner: (score1Val !== null && score2Val !== null) ? (score1Val > score2Val ? team1 : team2) : null,
                        unknownResult: isUnknownResult,
                        eloDelta1: elo1Delta,
                        eloDelta2: elo2Delta
                    };
                });
            }

            // Meias-Finais (E2)
            const meias = eliminationMatches.filter(m =>
                (m.Jornada || m.round) &&
                (m.Jornada?.startsWith('E2') || m.round?.startsWith('E2')) &&
                !(m.Jornada?.includes('L') || m.round?.includes('L'))
            );
            if (meias.length > 0) {
                bracketData["Meias-Finais"] = meias.map(match => {
                    const isUnknownResult = detectUnknownResult(match);
                    const team1 = resolveTeamName(match['Equipa 1']);
                    const team2 = resolveTeamName(match['Equipa 2']);
                    // ‚ö†Ô∏è IMPORTANTE: Se score estiver vazio no CSV, usar null (n√£o 0)
                    const score1Val = match['Golos 1'] ? parseFloat(match['Golos 1']) : null;
                    const score2Val = match['Golos 2'] ? parseFloat(match['Golos 2']) : null;

                    // Procurar dados de ELO no rawEloData (mesmo padr√£o do calend√°rio)
                    const eloMatch = sampleData.rawEloData ? sampleData.rawEloData.find(m =>
                        m.Jornada === match.Jornada &&
                        normalizeTeamName(m['Equipa 1']) === normalizeTeamName(team1) &&
                        normalizeTeamName(m['Equipa 2']) === normalizeTeamName(team2)
                    ) : null;

                    const elo1Delta = eloMatch && eloMatch['Elo Delta 1'] ? parseInt(eloMatch['Elo Delta 1']) : 0;
                    const elo2Delta = eloMatch && eloMatch['Elo Delta 2'] ? parseInt(eloMatch['Elo Delta 2']) : 0;

                    return {
                        team1: team1,
                        team2: team2,
                        score1: score1Val,
                        score2: score2Val,
                        winner: (score1Val !== null && score2Val !== null) ? (score1Val > score2Val ? team1 : team2) : null,
                        unknownResult: isUnknownResult,
                        eloDelta1: elo1Delta,
                        eloDelta2: elo2Delta
                    };
                });
            }

            // Final (E3)
            const final = eliminationMatches.filter(m =>
                (m.Jornada || m.round) &&
                (m.Jornada?.startsWith('E3') || m.round?.startsWith('E3')) &&
                !(m.Jornada?.includes('L') || m.round?.includes('L'))
            );

            // Jogo do 3¬∫ lugar (E3L) - na mesma ronda que a final
            const terceiroLugar = eliminationMatches.filter(m =>
                (m.Jornada || m.round) &&
                (m.Jornada === 'E3L' || m.round === 'E3L')
            );

            // Criar array da ronda final que inclui ambos os jogos
            const finalMatches = [];

            // Adicionar final primeiro
            if (final.length > 0) {
                finalMatches.push(...final.map(match => {
                    const isUnknownResult = detectUnknownResult(match);
                    const team1 = resolveTeamName(match['Equipa 1']);
                    const team2 = resolveTeamName(match['Equipa 2']);
                    // ‚ö†Ô∏è IMPORTANTE: Se score estiver vazio no CSV, usar null (n√£o 0)
                    const score1Val = match['Golos 1'] ? parseFloat(match['Golos 1']) : null;
                    const score2Val = match['Golos 2'] ? parseFloat(match['Golos 2']) : null;

                    // Procurar dados de ELO no rawEloData (mesmo padr√£o do calend√°rio)
                    const eloMatch = sampleData.rawEloData ? sampleData.rawEloData.find(m =>
                        m.Jornada === match.Jornada &&
                        normalizeTeamName(m['Equipa 1']) === normalizeTeamName(team1) &&
                        normalizeTeamName(m['Equipa 2']) === normalizeTeamName(team2)
                    ) : null;

                    const elo1Delta = eloMatch && eloMatch['Elo Delta 1'] ? parseInt(eloMatch['Elo Delta 1']) : 0;
                    const elo2Delta = eloMatch && eloMatch['Elo Delta 2'] ? parseInt(eloMatch['Elo Delta 2']) : 0;

                    return {
                        team1: team1,
                        team2: team2,
                        score1: score1Val,
                        score2: score2Val,
                        winner: (score1Val !== null && score2Val !== null) ? (score1Val > score2Val ? team1 : team2) : null,
                        unknownResult: isUnknownResult,
                        isThirdPlace: false,
                        eloDelta1: elo1Delta,
                        eloDelta2: elo2Delta
                    };
                }));
            }

            // Adicionar 3¬∫ lugar depois
            if (terceiroLugar.length > 0) {
                finalMatches.push(...terceiroLugar.map(match => {
                    const isUnknownResult = detectUnknownResult(match);
                    const team1 = resolveTeamName(match['Equipa 1']);
                    const team2 = resolveTeamName(match['Equipa 2']);
                    // ‚ö†Ô∏è IMPORTANTE: Se score estiver vazio no CSV, usar null (n√£o 0)
                    const score1Val = match['Golos 1'] ? parseFloat(match['Golos 1']) : null;
                    const score2Val = match['Golos 2'] ? parseFloat(match['Golos 2']) : null;

                    // Procurar dados de ELO no rawEloData (mesmo padr√£o do calend√°rio)
                    const eloMatch = sampleData.rawEloData ? sampleData.rawEloData.find(m =>
                        m.Jornada === match.Jornada &&
                        normalizeTeamName(m['Equipa 1']) === normalizeTeamName(team1) &&
                        normalizeTeamName(m['Equipa 2']) === normalizeTeamName(team2)
                    ) : null;

                    const elo1Delta = eloMatch && eloMatch['Elo Delta 1'] ? parseInt(eloMatch['Elo Delta 1']) : 0;
                    const elo2Delta = eloMatch && eloMatch['Elo Delta 2'] ? parseInt(eloMatch['Elo Delta 2']) : 0;

                    return {
                        team1: team1,
                        team2: team2,
                        score1: score1Val,
                        score2: score2Val,
                        winner: (score1Val !== null && score2Val !== null) ? (score1Val > score2Val ? team1 : team2) : null,
                        unknownResult: isUnknownResult,
                        isThirdPlace: true,
                        eloDelta1: elo1Delta,
                        eloDelta2: elo2Delta
                    };
                }));
            }

            if (finalMatches.length > 0) {
                bracketData["Final"] = finalMatches;
            }

            sampleData.bracket = bracketData;
            DebugUtils.debugBracket('bracket_created', bracketData);
            createBracket();
        }

        // Processar jogos secund√°rios (PM/LM)
        function processSecondaryMatches(secondaryMatches) {
            const bracketData = {};

            // Fun√ß√£o auxiliar para detectar "?" nos dados
            function detectUnknownResult(match) {
                const allKeys = Object.keys(match);
                for (let key of allKeys) {
                    const value = match[key];
                    if (value && value.toString().trim() === '?') {
                        return true;
                    }
                }
                return false;
            }

            // Determinar o tipo de bracket secund√°rio
            const hasPM = secondaryMatches.some(m => m.Jornada && m.Jornada.startsWith('PM'));
            const hasLM = secondaryMatches.some(m => m.Jornada && m.Jornada.startsWith('LM'));

            DebugUtils.debugSecondaryBracket('analyzing_games', {
                totalMatches: secondaryMatches.length,
                hasPM: hasPM,
                hasLM: hasLM,
                pmMatches: secondaryMatches.filter(m => m.Jornada && m.Jornada.startsWith('PM')).map(m => ({
                    jornada: m.Jornada,
                    equipa1: m['Equipa 1'],
                    equipa2: m['Equipa 2'],
                    golos1: m['Golos 1'],
                    golos2: m['Golos 2']
                }))
            });

            // Verificar se √© manuten√ß√£o ou promo√ß√£o baseado na estrutura
            const structure = analyzeModalityStructure();
            const isPromotion = structure.hasDivisions && structure.divisions.includes('2¬™ Divis√£o');

            if (hasPM) {
                sampleData.secondaryBracketType = isPromotion ? 'promotion-playoff' : 'maintenance-playoff';

                // PM1 (similar a quartos)
                const pm1 = secondaryMatches.filter(m => m.Jornada && m.Jornada.startsWith('PM1'));
                if (pm1.length > 0) {
                    bracketData["1¬™ Fase"] = pm1.map(match => {
                        const team1 = match['Equipa 1'];
                        const team2 = match['Equipa 2'];
                        // ‚ö†Ô∏è IMPORTANTE: Se score estiver vazio no CSV, usar null (n√£o 0)
                        const score1Val = match['Golos 1'] ? parseFloat(match['Golos 1']) : null;
                        const score2Val = match['Golos 2'] ? parseFloat(match['Golos 2']) : null;

                        // Procurar dados de ELO no rawEloData (mesmo padr√£o do calend√°rio)
                        const eloMatch = sampleData.rawEloData ? sampleData.rawEloData.find(m =>
                            m.Jornada === match.Jornada &&
                            normalizeTeamName(m['Equipa 1']) === normalizeTeamName(team1) &&
                            normalizeTeamName(m['Equipa 2']) === normalizeTeamName(team2)
                        ) : null;

                        const elo1Delta = eloMatch && eloMatch['Elo Delta 1'] ? parseInt(eloMatch['Elo Delta 1']) : 0;
                        const elo2Delta = eloMatch && eloMatch['Elo Delta 2'] ? parseInt(eloMatch['Elo Delta 2']) : 0;

                        return {
                            team1: team1,
                            team2: team2,
                            score1: score1Val,
                            score2: score2Val,
                            winner: (score1Val !== null && score2Val !== null) ? (score1Val > score2Val ? team1 : team2) : null,
                            unknownResult: detectUnknownResult(match),
                            eloDelta1: elo1Delta,
                            eloDelta2: elo2Delta
                        };
                    });
                }

                // PM2 (similar a meias/final)
                const pm2 = secondaryMatches.filter(m => m.Jornada && m.Jornada.startsWith('PM2'));
                if (pm2.length > 0) {
                    bracketData["Final"] = pm2.map(match => {
                        const team1 = match['Equipa 1'];
                        const team2 = match['Equipa 2'];
                        // ‚ö†Ô∏è IMPORTANTE: Se score estiver vazio no CSV, usar null (n√£o 0)
                        const score1Val = match['Golos 1'] ? parseFloat(match['Golos 1']) : null;
                        const score2Val = match['Golos 2'] ? parseFloat(match['Golos 2']) : null;

                        // Procurar dados de ELO no rawEloData (mesmo padr√£o do calend√°rio)
                        const eloMatch = sampleData.rawEloData ? sampleData.rawEloData.find(m =>
                            m.Jornada === match.Jornada &&
                            normalizeTeamName(m['Equipa 1']) === normalizeTeamName(team1) &&
                            normalizeTeamName(m['Equipa 2']) === normalizeTeamName(team2)
                        ) : null;

                        const elo1Delta = eloMatch && eloMatch['Elo Delta 1'] ? parseInt(eloMatch['Elo Delta 1']) : 0;
                        const elo2Delta = eloMatch && eloMatch['Elo Delta 2'] ? parseInt(eloMatch['Elo Delta 2']) : 0;

                        return {
                            team1: team1,
                            team2: team2,
                            score1: score1Val,
                            score2: score2Val,
                            winner: (score1Val !== null && score2Val !== null) ? (score1Val > score2Val ? team1 : team2) : null,
                            unknownResult: detectUnknownResult(match),
                            eloDelta1: elo1Delta,
                            eloDelta2: elo2Delta
                        };
                    });
                }

                // ‚úÖ ATRIBUIR bracketData para PM (playoff)
                DebugUtils.debugSecondaryBracket('before_assign', {
                    hasPM: hasPM,
                    hasStandings: false,
                    matchesCount: (bracketData["1¬™ Fase"]?.length || 0) + (bracketData["Final"]?.length || 0)
                });

                sampleData.secondaryBracket = bracketData;

                DebugUtils.debugSecondaryBracket('after_assign', {
                    hasPromotionPlayoffs: hasPM,
                    hasStandings: false
                });
            } else if (hasLM) {
                sampleData.secondaryBracketType = isPromotion ? 'promotion-league' : 'maintenance-league';

                // Calcular tabela de classifica√ß√£o da liguilha
                const teamStats = new Map();
                const lmMatches = [];

                // Processar todos os jogos LM
                secondaryMatches.forEach(match => {
                    if (match.Jornada && match.Jornada.startsWith('LM')) {
                        // ‚úÖ RESOLVER placeholders antes de processar estat√≠sticas
                        const team1 = resolveTeamName(match['Equipa 1']);
                        const team2 = resolveTeamName(match['Equipa 2']);
                        // ‚ö†Ô∏è IMPORTANTE: Se score estiver vazio no CSV, usar null (n√£o 0)
                        const score1 = match['Golos 1'] ? parseFloat(match['Golos 1']) : null;
                        const score2 = match['Golos 2'] ? parseFloat(match['Golos 2']) : null;
                        const isUnknown = detectUnknownResult(match);
                        const winner = (score1 !== null && score2 !== null) ? (score1 > score2 ? team1 : (score2 > score1 ? team2 : null)) : null;

                        DebugUtils.debugSecondaryBracket('lm_match', { team1, team2, score1, score2, winner });

                        lmMatches.push({
                            team1: team1,
                            team2: team2,
                            score1: score1,
                            score2: score2,
                            unknownResult: isUnknown
                        });

                        // Inicializar equipas SEMPRE (mesmo que jogo n√£o tenha acontecido)
                        if (!teamStats.has(team1)) {
                            teamStats.set(team1, {
                                team: team1,
                                played: 0,
                                wins: 0,
                                draws: 0,
                                losses: 0,
                                goalsFor: 0,
                                goalsAgainst: 0,
                                goalDiff: 0,
                                points: 0
                            });
                        }
                        if (!teamStats.has(team2)) {
                            teamStats.set(team2, {
                                team: team2,
                                played: 0,
                                wins: 0,
                                draws: 0,
                                losses: 0,
                                goalsFor: 0,
                                goalsAgainst: 0,
                                goalDiff: 0,
                                points: 0
                            });
                        }

                        // Apenas contar estat√≠sticas se resultado conhecido
                        if (!isUnknown && score1 !== null && score2 !== null) {
                            const stats1 = teamStats.get(team1);
                            const stats2 = teamStats.get(team2);

                            // Atualizar jogos disputados
                            stats1.played++;
                            stats2.played++;

                            // Atualizar golos
                            stats1.goalsFor += score1;
                            stats1.goalsAgainst += score2;
                            stats2.goalsFor += score2;
                            stats2.goalsAgainst += score1;

                            // Determinar resultado
                            if (score1 > score2) {
                                stats1.wins++;
                                stats1.points += 3;
                                stats2.losses++;
                            } else if (score2 > score1) {
                                stats2.wins++;
                                stats2.points += 3;
                                stats1.losses++;
                            } else {
                                stats1.draws++;
                                stats2.draws++;
                                stats1.points++;
                                stats2.points++;
                            }

                            // Calcular diferen√ßa de golos
                            stats1.goalDiff = stats1.goalsFor - stats1.goalsAgainst;
                            stats2.goalDiff = stats2.goalsFor - stats2.goalsAgainst;
                        }
                    }
                });

                // Converter para array e ordenar
                const standings = Array.from(teamStats.values()).sort((a, b) => {
                    // Ordenar por pontos (desc), depois diferen√ßa golos (desc), depois golos marcados (desc)
                    if (b.points !== a.points) return b.points - a.points;
                    if (b.goalDiff !== a.goalDiff) return b.goalDiff - a.goalDiff;
                    return b.goalsFor - a.goalsFor;
                });

                // Guardar tabela e jogos para exibi√ß√£o
                sampleData.secondaryBracket = {
                    isTable: true,
                    standings: standings,
                    matches: lmMatches
                };
            }

            DebugUtils.debugSecondaryBracket('created', {
                type: sampleData.secondaryBracketType,
                hasPM: hasPM,
                hasLM: hasLM,
                bracketDataKeys: Object.keys(bracketData),
                bracketData: bracketData,
                secondaryBracket: sampleData.secondaryBracket,
                secondaryBracketKeys: Object.keys(sampleData.secondaryBracket || {}),
                secondaryBracketLength: Object.keys(sampleData.secondaryBracket || {}).length
            });

            DebugUtils.debugBracket('secondary_bracket_created', { type: sampleData.secondaryBracketType, data: sampleData.secondaryBracket });
            createSecondaryBracket();
        }

        // Criar bracket previsto com base nas equipas qualificadas
        function createPredictedBracket(qualifiedTeams) {
            DebugUtils.debugPredictedBracket('called', qualifiedTeams);

            if (!qualifiedTeams || qualifiedTeams.length < 8) {
                console.warn('‚ö†Ô∏è createPredictedBracket: equipas insuficientes', qualifiedTeams ? qualifiedTeams.length : 0);
                return {};
            }

            DebugUtils.debugPredictedBracket('creating');

            // Gerar confrontos dos quartos de final (1¬∫ vs 8¬∫, 4¬∫ vs 5¬∫, 2¬∫ vs 7¬∫, 3¬∫ vs 6¬∫)
            const bracketData = {
                "Quartos de Final": [
                    {
                        team1: qualifiedTeams[0],  // 1¬∫
                        team2: qualifiedTeams[7],  // 8¬∫
                        score1: null,
                        score2: null,
                        winner: null,
                        predicted: true
                    },
                    {
                        team1: qualifiedTeams[3],  // 4¬∫
                        team2: qualifiedTeams[4],  // 5¬∫
                        score1: null,
                        score2: null,
                        winner: null,
                        predicted: true
                    },
                    {
                        team1: qualifiedTeams[1],  // 2¬∫
                        team2: qualifiedTeams[6],  // 7¬∫
                        score1: null,
                        score2: null,
                        winner: null,
                        predicted: true
                    },
                    {
                        team1: qualifiedTeams[2],  // 3¬∫
                        team2: qualifiedTeams[5],  // 6¬∫
                        score1: null,
                        score2: null,
                        winner: null,
                        predicted: true
                    }
                ],
                "Meias-Finais": [
                    {
                        team1: "Vencedor Q1",
                        team2: "Vencedor Q2",
                        score1: null,
                        score2: null,
                        winner: null,
                        predicted: true
                    },
                    {
                        team1: "Vencedor Q3",
                        team2: "Vencedor Q4",
                        score1: null,
                        score2: null,
                        winner: null,
                        predicted: true
                    }
                ],
                "3¬∫ Lugar": [
                    {
                        team1: "Perdedor M1",
                        team2: "Perdedor M2",
                        score1: null,
                        score2: null,
                        winner: null,
                        predicted: true,
                        isThirdPlace: true
                    }
                ],
                "Final": [
                    {
                        team1: "Vencedor M1",
                        team2: "Vencedor M2",
                        score1: null,
                        score2: null,
                        winner: null,
                        predicted: true
                    }
                ]
            };

            return bracketData;
        }

        // Criar bracket de exemplo
        function createSampleBracket() {
            if (!sampleData.teams || sampleData.teams.length === 0) {
                sampleData.bracket = {};
                createBracket();
                return;
            }

            // Criar bracket de exemplo com as equipas dispon√≠veis
            const teams = sampleData.teams.slice(0, 8); // Usar at√© 8 equipas

            sampleData.bracket = {
                "Quartos de Final": [
                    {
                        team1: teams[0]?.name || "Equipa 1",
                        team2: teams[1]?.name || "Equipa 2",
                        score1: 2,
                        score2: 1,
                        winner: teams[0]?.name || "Equipa 1"
                    },
                    {
                        team1: teams[2]?.name || "Equipa 3",
                        team2: teams[3]?.name || "Equipa 4",
                        score1: 3,
                        score2: 0,
                        winner: teams[2]?.name || "Equipa 3"
                    },
                    {
                        team1: teams[4]?.name || "Equipa 5",
                        team2: teams[5]?.name || "Equipa 6",
                        score1: 1,
                        score2: 2,
                        winner: teams[5]?.name || "Equipa 6"
                    },
                    {
                        team1: teams[6]?.name || "Equipa 7",
                        team2: teams[7]?.name || "Equipa 8",
                        score1: 4,
                        score2: 1,
                        winner: teams[6]?.name || "Equipa 7"
                    }
                ],
                "Meias-Finais": [
                    {
                        team1: teams[0]?.name || "Equipa 1",
                        team2: teams[2]?.name || "Equipa 3",
                        score1: 2,
                        score2: 3,
                        winner: teams[2]?.name || "Equipa 3"
                    },
                    {
                        team1: teams[5]?.name || "Equipa 6",
                        team2: teams[6]?.name || "Equipa 7",
                        score1: 1,
                        score2: 0,
                        winner: teams[5]?.name || "Equipa 6"
                    }
                ],
                "3¬∫ Lugar": [
                    {
                        team1: teams[0]?.name || "Equipa 1",
                        team2: teams[6]?.name || "Equipa 7",
                        score1: null,
                        score2: null,
                        winner: null
                    }
                ],
                "Final": [
                    {
                        team1: teams[2]?.name || "Equipa 3",
                        team2: teams[5]?.name || "Equipa 6",
                        score1: null,
                        score2: null,
                        winner: null
                    }
                ]
            };

            createBracket();
        }

        // Criar bracket
        function createBracket() {
            const container = document.getElementById('bracketContainer');

            if (!sampleData.bracket || Object.keys(sampleData.bracket).length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">Bracket n√£o dispon√≠vel para esta modalidade</p>';
                return;
            }

            container.innerHTML = '';

            // Obter mapa de equipas qualificadas para mostrar labels - for√ßar refresh
            const qualified = getQualifiedTeams(true);
            DebugUtils.debugBracket('qualified_teams', qualified);
            const qualificationLabels = {};

            qualified.legend.forEach(item => {
                if (item.type === 'playoff') {
                    let label = `${item.position}¬∫`;
                    if (item.division === '2¬™' && item.group) {
                        label += ` Grupo ${item.group}`;
                    } else if (item.division === '2¬™') {
                        label += ` 2¬™ Div`;
                    } else if (item.division === '1¬™') {
                        label += ` 1¬™ Div`;
                    }
                    qualificationLabels[item.team] = label;
                }
            });

            Object.entries(sampleData.bracket).forEach(([round, matches]) => {
                const roundDiv = document.createElement('div');
                roundDiv.className = 'bracket-round';

                const title = document.createElement('h3');
                title.textContent = round;
                roundDiv.appendChild(title);

                matches.forEach((match, index) => {
                    // Adicionar subt√≠tulo para o 3¬∫ lugar se for o caso
                    if (match.isThirdPlace && !document.querySelector('.third-place-header')) {
                        const thirdPlaceHeader = document.createElement('h4');
                        thirdPlaceHeader.className = 'third-place-header';
                        thirdPlaceHeader.textContent = '3¬∫ Lugar';
                        thirdPlaceHeader.style.cssText = `
                            text-align: center;
                            color: #666;
                            margin: 30px 0 10px 0;
                            padding: 8px;
                            background: #f5f5f5;
                            border-radius: 8px;
                            font-weight: 600;
                            font-size: 0.9em;
                        `;
                        roundDiv.appendChild(thirdPlaceHeader);
                    }

                    const matchDiv = document.createElement('div');
                    matchDiv.className = 'bracket-match';

                    // Resolver nomes (substituir placeholders por equipas reais)
                    const resolvedTeam1 = resolveTeamName(match.team1);
                    const resolvedTeam2 = resolveTeamName(match.team2);

                    // Obter informa√ß√µes das equipas - aplicar normaliza√ß√£o
                    const team1Info = getCourseInfo(normalizeTeamName(resolvedTeam1));
                    const team2Info = getCourseInfo(normalizeTeamName(resolvedTeam2));

                    // Usar cor da equipa ou cinza neutro como fallback
                    const team1Color = team1Info.colors ? team1Info.colors[0] : '#6c757d';
                    const team2Color = team2Info.colors ? team2Info.colors[0] : '#6c757d';

                    const team1Div = document.createElement('div');
                    // ‚úÖ MOSTRAR vencedor MESMO com unknownResult (s√≥ n√£o mostrar se predicted ou sem score)
                    const hasScore = (match.score1 !== null && match.score2 !== null);
                    const matchPlayed = hasScore && !match.predicted; // Permitir unknownResult
                    const showScore = hasScore && !match.predicted; // Mostrar score mesmo se unknownResult
                    team1Div.className = `bracket-team ${matchPlayed && match.winner === match.team1 ? 'winner' : ''}`;

                    // Definir cor de fundo se for vencedor E jogo foi realizado, sen√£o border colorida
                    if (matchPlayed && match.winner === match.team1) {
                        team1Div.style.background = `linear-gradient(135deg, ${team1Color}, ${team1Color}dd)`;
                        team1Div.style.borderLeftColor = team1Color;
                    } else {
                        team1Div.style.borderLeftColor = team1Color;
                    }

                    // Preparar indicador de ELO
                    const elo1Delta = match.eloDelta1 || 0;
                    const elo1Html = matchPlayed && elo1Delta !== 0 ?
                        `<span class="bracket-elo-change ${elo1Delta > 0 ? 'positive' : 'negative'}">${elo1Delta > 0 ? '+' : ''}${elo1Delta}</span>` : '';

                    team1Div.innerHTML = `
                        <div class="bracket-team-content">
                            ${team1Info.emblemPath ?
                            `<img src="${team1Info.emblemPath}" alt="${normalizeTeamName(resolvedTeam1)}" class="bracket-team-emblem" onerror="this.style.display='none'">` :
                            ''
                        }
                            <span>${team1Info.displayName || normalizeTeamName(resolvedTeam1)}</span>
                        </div>
                        <span class="score">${showScore ? match.score1 : '-'}</span>
                        ${elo1Html}
                    `;

                    // Adicionar label de qualifica√ß√£o acima da equipa 1 (mesma l√≥gica da liguilha - todas as rondas)
                    const legendItem1 = qualified.legend.find(item =>
                        normalizeTeamName(item.team) === normalizeTeamName(resolvedTeam1)
                    );

                    if (legendItem1) {
                        let qualLabel = '';
                        if (legendItem1.division === '1¬™') {
                            qualLabel = `${legendItem1.position}¬∫ 1¬™ Div`;
                        } else if (legendItem1.division === '2¬™') {
                            if (legendItem1.group) {
                                qualLabel = `${legendItem1.actualPosition || legendItem1.position}¬∫ Gr. ${legendItem1.group}`;
                            } else {
                                qualLabel = `${legendItem1.actualPosition || legendItem1.position}¬∫ 2¬™ Div`;
                            }
                        }

                        if (qualLabel) {
                            const label1 = document.createElement('div');
                            label1.className = 'qualification-label qualification-label-top';
                            label1.textContent = qualLabel;
                            matchDiv.appendChild(label1);
                        }
                    }

                    const team2Div = document.createElement('div');
                    // ‚ö†Ô∏è Usar mesma l√≥gica de matchPlayed calculada acima
                    team2Div.className = `bracket-team ${matchPlayed && match.winner === match.team2 ? 'winner' : ''}`;

                    // Definir cor de fundo se for vencedor E jogo foi realizado, sen√£o border colorida
                    if (matchPlayed && match.winner === match.team2) {
                        team2Div.style.background = `linear-gradient(135deg, ${team2Color}, ${team2Color}dd)`;
                        team2Div.style.borderLeftColor = team2Color;
                    } else {
                        team2Div.style.borderLeftColor = team2Color;
                    }

                    // Preparar indicador de ELO
                    const elo2Delta = match.eloDelta2 || 0;
                    const elo2Html = matchPlayed && elo2Delta !== 0 ?
                        `<span class="bracket-elo-change ${elo2Delta > 0 ? 'positive' : 'negative'}">${elo2Delta > 0 ? '+' : ''}${elo2Delta}</span>` : '';

                    team2Div.innerHTML = `
                        <div class="bracket-team-content">
                            ${team2Info.emblemPath ?
                            `<img src="${team2Info.emblemPath}" alt="${normalizeTeamName(resolvedTeam2)}" class="bracket-team-emblem" onerror="this.style.display='none'">` :
                            ''
                        }
                            <span>${team2Info.displayName || normalizeTeamName(resolvedTeam2)}</span>
                        </div>
                        <span class="score">${showScore ? match.score2 : '-'}</span>
                        ${elo2Html}
                    `;

                    matchDiv.appendChild(team1Div);
                    matchDiv.appendChild(team2Div);

                    // Adicionar label de qualifica√ß√£o abaixo da equipa 2 (mesma l√≥gica da liguilha - todas as rondas)
                    const legendItem2 = qualified.legend.find(item =>
                        normalizeTeamName(item.team) === normalizeTeamName(resolvedTeam2)
                    );

                    if (legendItem2) {
                        let qualLabel = '';
                        if (legendItem2.division === '1¬™') {
                            qualLabel = `${legendItem2.position}¬∫ 1¬™ Div`;
                        } else if (legendItem2.division === '2¬™') {
                            if (legendItem2.group) {
                                qualLabel = `${legendItem2.actualPosition || legendItem2.position}¬∫ Gr. ${legendItem2.group}`;
                            } else {
                                qualLabel = `${legendItem2.actualPosition || legendItem2.position}¬∫ 2¬™ Div`;
                            }
                        }

                        if (qualLabel) {
                            const label2 = document.createElement('div');
                            label2.className = 'qualification-label qualification-label-bottom';
                            label2.textContent = qualLabel;
                            matchDiv.appendChild(label2);
                        }
                    }

                    // Adicionar indica√ß√£o de bracket previsto se aplic√°vel
                    if (match.predicted) {
                        const predictedIndicator = document.createElement('div');
                        predictedIndicator.className = 'predicted-match-indicator';
                        predictedIndicator.innerHTML = '<small style="color: #2196F3; font-style: italic; text-align: center; margin-top: 5px;">üìÖ Confronto Previsto</small>';
                        matchDiv.appendChild(predictedIndicator);
                    }

                    // Adicionar indica√ß√£o de resultado desconhecido se aplic√°vel
                    if (match.unknownResult) {
                        const unknownIndicator = document.createElement('div');
                        unknownIndicator.className = 'unknown-result-indicator';
                        unknownIndicator.innerHTML = '<small style="color: #666; font-style: italic; text-align: center; margin-top: 5px;">‚ö†Ô∏è Resultado Desconhecido</small>';
                        matchDiv.appendChild(unknownIndicator);
                    }

                    roundDiv.appendChild(matchDiv);
                });

                container.appendChild(roundDiv);
            });
        }

        // Criar bracket secund√°rio (Manuten√ß√£o/Promo√ß√£o/Liguilha)
        function createSecondaryBracket() {
            const container = document.getElementById('secondaryBracketContainer');
            const card = document.getElementById('secondaryBracketCard');
            const title = document.getElementById('secondaryBracketTitle');

            DebugUtils.debugSecondaryBracket('started', {
                secondaryBracket: sampleData.secondaryBracket,
                secondaryBracketKeys: Object.keys(sampleData.secondaryBracket || {}),
                isEmpty: !sampleData.secondaryBracket || Object.keys(sampleData.secondaryBracket).length === 0,
                bracketType: sampleData.secondaryBracketType
            });

            if (!sampleData.secondaryBracket || Object.keys(sampleData.secondaryBracket).length === 0) {
                console.warn('‚ö†Ô∏è Bracket secund√°rio VAZIO - escondendo card');
                card.style.display = 'none';
                return;
            }

            // Determinar t√≠tulo baseado no tipo de bracket secund√°rio
            const bracketType = sampleData.secondaryBracketType || 'playoff';
            if (bracketType === 'maintenance-playoff') {
                title.textContent = 'Playoff de Manuten√ß√£o';
            } else if (bracketType === 'maintenance-league') {
                title.textContent = 'Liguilha de Manuten√ß√£o';
            } else if (bracketType === 'promotion-playoff') {
                title.textContent = 'Playoff de Promo√ß√£o';
            } else if (bracketType === 'promotion-league') {
                title.textContent = 'Liguilha de Promo√ß√£o';
            } else {
                title.textContent = 'Playoff/Liguilha';
            }

            card.style.display = 'block';
            container.innerHTML = '';

            // Criar mapa de qualificationLabels para o bracket secund√°rio - for√ßar refresh
            const qualified = getQualifiedTeams(true);
            DebugUtils.debugSecondaryBracket('qualified_teams', qualified);
            const qualificationLabels = {};

            qualified.legend.forEach(item => {
                const relevantTypes = ['maintenance-playoff', 'maintenance-league', 'promotion-playoff', 'promotion-league'];
                if (relevantTypes.includes(item.type)) {
                    let label = `${item.position}¬∫`;
                    if (item.division === '2¬™' && item.group) {
                        label += ` Grupo ${item.group}`;
                    } else if (item.division === '2¬™') {
                        label += ` 2¬™ Div`;
                    } else if (item.division === '1¬™') {
                        label += ` 1¬™ Div`;
                    }
                    qualificationLabels[item.team] = label;
                }
            });

            // Verificar se √© uma tabela (liguilha) ou bracket (playoff)
            if (sampleData.secondaryBracket.isTable) {
                // Criar tabela de classifica√ß√£o para liguilhas
                const tableDiv = document.createElement('div');
                tableDiv.className = 'bracket-league-table';

                const table = document.createElement('table');
                table.innerHTML = `
                    <thead>
                        <tr>
                            <th>Pos</th>
                            <th>Equipa</th>
                            <th>J</th>
                            <th>V</th>
                            <th>E</th>
                            <th>D</th>
                            <th>GM</th>
                            <th>GS</th>
                            <th>¬±</th>
                            <th>Pts</th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                `;

                const tbody = table.querySelector('tbody');

                // Obter informa√ß√µes de qualifica√ß√£o
                const qualified = getQualifiedTeams();

                sampleData.secondaryBracket.standings.forEach((stats, index) => {
                    // Resolver nome da equipa
                    const resolvedTeam = resolveTeamName(stats.team);
                    const teamInfo = getCourseInfo(normalizeTeamName(resolvedTeam));

                    // Encontrar de onde veio esta equipa
                    let qualLabel = '';
                    let qualClass = '';
                    const legendItem = qualified.legend.find(item =>
                        item.team === resolvedTeam &&
                        (item.type === 'maintenance-league' || item.type === 'promotion-league')
                    );

                    if (legendItem) {
                        if (legendItem.division === '1¬™') {
                            qualLabel = `${legendItem.position}¬∫ 1¬™ Div`;
                            qualClass = 'qual-1div';
                        } else if (legendItem.division === '2¬™') {
                            if (legendItem.group) {
                                qualLabel = `${legendItem.actualPosition || legendItem.position}¬∫ Gr. ${legendItem.group}`;
                            } else {
                                qualLabel = `${legendItem.actualPosition || legendItem.position}¬∫ 2¬™ Div`;
                            }
                            qualClass = 'qual-2div';
                        }
                    }

                    const row = document.createElement('tr');

                    row.innerHTML = `
                        <td class="position">${index + 1}</td>
                        <td class="team-cell">
                            ${qualLabel ? `<span class="team-qualification-label ${qualClass}">${qualLabel}</span>` : ''}
                            ${teamInfo.emblemPath ?
                            `<img src="${teamInfo.emblemPath}" alt="${resolvedTeam}" class="team-emblem" onerror="this.style.display='none'">` :
                            ''
                        }
                            <span>${teamInfo.displayName || resolvedTeam}</span>
                        </td>
                        <td>${stats.played}</td>
                        <td>${stats.wins}</td>
                        <td>${stats.draws}</td>
                        <td>${stats.losses}</td>
                        <td>${stats.goalsFor}</td>
                        <td>${stats.goalsAgainst}</td>
                        <td class="${stats.goalDiff > 0 ? 'positive' : stats.goalDiff < 0 ? 'negative' : ''}">${stats.goalDiff > 0 ? '+' : ''}${stats.goalDiff}</td>
                        <td class="points"><strong>${stats.points}</strong></td>
                    `;

                    tbody.appendChild(row);
                });

                tableDiv.appendChild(table);
                container.appendChild(tableDiv);
            } else {
                // Exibir como bracket tradicional
                Object.entries(sampleData.secondaryBracket).forEach(([round, matches]) => {
                    const roundDiv = document.createElement('div');
                    roundDiv.className = 'bracket-round';

                    const roundTitle = document.createElement('h3');
                    roundTitle.textContent = round;
                    roundDiv.appendChild(roundTitle);

                    matches.forEach(match => {
                        const matchDiv = document.createElement('div');
                        matchDiv.className = 'bracket-match';

                        // Resolver nomes (substituir placeholders por equipas reais)
                        const resolvedTeam1 = resolveTeamName(match.team1);
                        const resolvedTeam2 = resolveTeamName(match.team2);

                        // Obter informa√ß√µes das equipas
                        const team1Info = getCourseInfo(normalizeTeamName(resolvedTeam1));
                        const team2Info = getCourseInfo(normalizeTeamName(resolvedTeam2));

                        // Usar cor da equipa ou cinza neutro como fallback
                        const team1Color = team1Info.colors ? team1Info.colors[0] : '#6c757d';
                        const team2Color = team2Info.colors ? team2Info.colors[0] : '#6c757d';

                        const team1Div = document.createElement('div');
                        // ‚úÖ MOSTRAR vencedor MESMO com unknownResult (s√≥ n√£o mostrar se predicted ou sem score)
                        const hasScore = (match.score1 !== null && match.score2 !== null);
                        const matchPlayed = hasScore && !match.predicted; // Permitir unknownResult
                        const showScore = hasScore && !match.predicted; // Mostrar score mesmo se unknownResult
                        team1Div.className = `bracket-team ${matchPlayed && match.winner === match.team1 ? 'winner' : ''}`;

                        if (matchPlayed && match.winner === match.team1) {
                            team1Div.style.background = `linear-gradient(135deg, ${team1Color}, ${team1Color}dd)`;
                            team1Div.style.borderLeftColor = team1Color;
                        } else {
                            team1Div.style.borderLeftColor = team1Color;
                        }

                        // Preparar indicador de ELO
                        const elo1Delta = match.eloDelta1 || 0;
                        const elo1Html = matchPlayed && elo1Delta !== 0 ?
                            `<span class="bracket-elo-change ${elo1Delta > 0 ? 'positive' : 'negative'}">${elo1Delta > 0 ? '+' : ''}${elo1Delta}</span>` : '';

                        team1Div.innerHTML = `
                        <div class="bracket-team-content">
                            ${team1Info.emblemPath ?
                                `<img src="${team1Info.emblemPath}" alt="${normalizeTeamName(resolvedTeam1)}" class="bracket-team-emblem" onerror="this.style.display='none'">` :
                                ''
                            }
                            <span>${team1Info.displayName || normalizeTeamName(resolvedTeam1)}</span>
                        </div>
                        <span class="score">${showScore ? match.score1 : '-'}</span>
                        ${elo1Html}
                    `;

                        // Adicionar label de qualifica√ß√£o acima da equipa 1 (mesma l√≥gica da liguilha)
                        const legendItem1 = qualified.legend.find(item =>
                            normalizeTeamName(item.team) === normalizeTeamName(resolvedTeam1)
                        );

                        if (legendItem1) {
                            let qualLabel = '';
                            if (legendItem1.division === '1¬™') {
                                qualLabel = `${legendItem1.position}¬∫ 1¬™ Div`;
                            } else if (legendItem1.division === '2¬™') {
                                if (legendItem1.group) {
                                    qualLabel = `${legendItem1.actualPosition || legendItem1.position}¬∫ Gr. ${legendItem1.group}`;
                                } else {
                                    qualLabel = `${legendItem1.actualPosition || legendItem1.position}¬∫ 2¬™ Div`;
                                }
                            }

                            if (qualLabel) {
                                const label1 = document.createElement('div');
                                label1.className = 'qualification-label qualification-label-top';
                                label1.textContent = qualLabel;
                                matchDiv.appendChild(label1);
                            }
                        }

                        const team2Div = document.createElement('div');
                        // ‚ö†Ô∏è Usar mesma l√≥gica de matchPlayed calculada acima
                        team2Div.className = `bracket-team ${matchPlayed && match.winner === match.team2 ? 'winner' : ''}`;

                        if (matchPlayed && match.winner === match.team2) {
                            team2Div.style.background = `linear-gradient(135deg, ${team2Color}, ${team2Color}dd)`;
                            team2Div.style.borderLeftColor = team2Color;
                        } else {
                            team2Div.style.borderLeftColor = team2Color;
                        }

                        // Preparar indicador de ELO
                        const elo2Delta = match.eloDelta2 || 0;
                        const elo2Html = matchPlayed && elo2Delta !== 0 ?
                            `<span class="bracket-elo-change ${elo2Delta > 0 ? 'positive' : 'negative'}">${elo2Delta > 0 ? '+' : ''}${elo2Delta}</span>` : '';

                        team2Div.innerHTML = `
                        <div class="bracket-team-content">
                            ${team2Info.emblemPath ?
                                `<img src="${team2Info.emblemPath}" alt="${normalizeTeamName(resolvedTeam2)}" class="bracket-team-emblem" onerror="this.style.display='none'">` :
                                ''
                            }
                            <span>${team2Info.displayName || normalizeTeamName(resolvedTeam2)}</span>
                        </div>
                        <span class="score">${showScore ? match.score2 : '-'}</span>
                        ${elo2Html}
                    `;

                        matchDiv.appendChild(team1Div);
                        matchDiv.appendChild(team2Div);

                        // Adicionar label de qualifica√ß√£o abaixo da equipa 2 (mesma l√≥gica da liguilha)
                        const legendItem2 = qualified.legend.find(item =>
                            normalizeTeamName(item.team) === normalizeTeamName(resolvedTeam2)
                        );

                        if (legendItem2) {
                            let qualLabel = '';
                            if (legendItem2.division === '1¬™') {
                                qualLabel = `${legendItem2.position}¬∫ 1¬™ Div`;
                            } else if (legendItem2.division === '2¬™') {
                                if (legendItem2.group) {
                                    qualLabel = `${legendItem2.actualPosition || legendItem2.position}¬∫ Gr. ${legendItem2.group}`;
                                } else {
                                    qualLabel = `${legendItem2.actualPosition || legendItem2.position}¬∫ 2¬™ Div`;
                                }
                            }

                            if (qualLabel) {
                                const label2 = document.createElement('div');
                                label2.className = 'qualification-label qualification-label-bottom';
                                label2.textContent = qualLabel;
                                matchDiv.appendChild(label2);
                            }
                        }

                        if (match.unknownResult) {
                            const unknownIndicator = document.createElement('div');
                            unknownIndicator.className = 'unknown-result-indicator';
                            unknownIndicator.innerHTML = '<small style="color: #666; font-style: italic; text-align: center; margin-top: 5px;">‚ö†Ô∏è Resultado Desconhecido</small>';
                            matchDiv.appendChild(unknownIndicator);
                        }

                        roundDiv.appendChild(matchDiv);
                    });

                    container.appendChild(roundDiv);
                });
            }
        }

        // Atualizar filtros r√°pidos baseado na estrutura da modalidade
        function updateQuickFilters() {
            DebugUtils.debugModalityAnalysis('updating_filters');
            const structure = analyzeModalityStructure();
            DebugUtils.debugModalityAnalysis('structure_detected', structure);
            const filtersContainer = document.getElementById('quickFilters');

            // Limpar filtros existentes
            filtersContainer.innerHTML = '';

            const top3Btn = document.createElement('button');
            top3Btn.className = 'filter-btn';
            top3Btn.textContent = 'Top 3';
            top3Btn.dataset.filter = 'top3';
            filtersContainer.appendChild(top3Btn);

            // Usar a mesma l√≥gica da tabela de classifica√ß√£o
            const divisions = Object.keys(sampleData.rankings);

            // Se for liga √∫nica, n√£o adicionar filtros de divis√£o/grupo
            if (structure.type !== 'single-league') {
                divisions.forEach(division => {
                    const btn = document.createElement('button');
                    btn.className = 'filter-btn';
                    btn.textContent = division;
                    btn.dataset.filter = 'division';
                    btn.dataset.division = division;
                    filtersContainer.appendChild(btn);
                });
            }

            // Adicionar filtros finais
            const playoffsBtn = document.createElement('button');
            playoffsBtn.className = 'filter-btn';
            playoffsBtn.textContent = 'Playoffs';
            playoffsBtn.onclick = filterPlayoffs;
            filtersContainer.appendChild(playoffsBtn);

            const resetBtn = document.createElement('button');
            resetBtn.className = 'filter-btn';
            resetBtn.textContent = 'Resetar Filtro';
            resetBtn.onclick = resetFilter;
            filtersContainer.appendChild(resetBtn);
        }

        // ==================== UTILITIES ====================

        /**
         * Utilit√°rios para trabalhar com equipas, especialmente equipas B
         */
        const TeamUtils = {
            /**
             * Verifica se uma equipa √© equipa B
             * @param {string} name - Nome da equipa
             * @returns {boolean}
             */
            isTeamB(name) {
                return /\sB$/i.test(name?.trim());
            },

            /**
             * Obt√©m o nome da equipa A correspondente a uma equipa B
             * @param {string} teamBName - Nome da equipa B
             * @returns {string} Nome da equipa A
             */
            getTeamA(teamBName) {
                return teamBName?.trim().replace(/\sB$/i, '');
            },

            /**
             * Verifica se a equipa A correspondente est√° em posi√ß√£o de descida
             * @param {string} teamBName - Nome da equipa B
             * @param {Array} div1Teams - Lista de equipas da 1¬™ divis√£o (ordenadas por classifica√ß√£o)
             * @returns {boolean}
             */
            isTeamAInRelegation(teamBName, div1Teams) {
                if (!this.isTeamB(teamBName)) {
                    return false;
                }

                const teamAName = this.getTeamA(teamBName);
                const teamAIndex = div1Teams.findIndex(t => t.team === teamAName);

                if (teamAIndex === -1) {
                    return false; // Equipa A n√£o est√° na 1¬™ divis√£o
                }

                // Considerar em risco de descida se est√° nos √∫ltimos 3 lugares (10¬∫, 11¬∫, 12¬∫)
                return teamAIndex >= div1Teams.length - 3;
            },

            /**
             * Normaliza nome de equipa para compara√ß√µes
             * @param {string} name - Nome da equipa
             * @returns {string}
             */
            normalizeName(name) {
                return name?.trim().replace(/\s+/g, ' ');
            },

            /**
             * Encontra primeira equipa n√£o-B numa lista
             * @param {Array} teams - Lista de equipas
             * @param {number} startIndex - √çndice inicial para come√ßar a procura
             * @returns {Object} { team, index } ou null se n√£o encontrar
             */
            findFirstNonBTeam(teams, startIndex = 0) {
                for (let i = startIndex; i < teams.length; i++) {
                    if (!this.isTeamB(teams[i].team)) {
                        return { team: teams[i], index: i };
                    }
                }
                return null;
            }
        };

        // ==================== STRATEGY PATTERN PARA PROGRESS√ÉO ====================

        // Estrat√©gias de progress√£o por tipo de estrutura de torneio
        const progressionStrategies = {
            'single-league': (context) => {
                // Liga √∫nica sem divis√µes nem grupos
                // REGRA: Passam sempre 8 aos playoffs
                if (context.position <= 8) {
                    return {
                        type: 'playoffs',
                        description: 'Qualifica√ß√£o para play-offs'
                    };
                }
                return null;
            },

            'groups-only': (context) => {
                // Formato: Sem divis√µes, sempre 2 grupos
                // Passam os primeiros 4 de cada grupo aos play-offs
                if (context.position <= 4) {
                    return {
                        type: 'playoffs',
                        description: 'Qualifica√ß√£o para play-offs'
                    };
                }
                return null;
            },

            'divisions-only': (context) => {
                // Formato: M√∫ltiplas divis√µes sem grupos
                const { position, totalTeams, divisionNum, structure,
                    hasMaintenancePlayoffs, hasMaintenanceLeague } = context;

                if (divisionNum === 1) {
                    return progressionStrategies._firstDivisionOnly(context);
                } else if (divisionNum === 2) {
                    return progressionStrategies._secondDivisionOnly(context);
                } else {
                    return progressionStrategies._lowerDivisions(context);
                }
            },

            'divisions-and-groups': (context) => {
                // Formato: Divis√µes com grupos
                const { divisionNum } = context;

                if (divisionNum === 1) {
                    return progressionStrategies._firstDivisionWithGroups(context);
                } else if (divisionNum === 2) {
                    return progressionStrategies._secondDivisionWithGroups(context);
                } else {
                    return progressionStrategies._lowerDivisions(context);
                }
            },

            // Estrat√©gias auxiliares para divis√µes espec√≠ficas
            _firstDivisionOnly: (context) => {
                const { position, totalTeams, structure,
                    hasMaintenancePlayoffs, hasMaintenanceLeague } = context;

                const has2ndDivision = structure.divisions.includes('2');
                const relegationRules = getRelegationRules();
                const playoffSpots = calculatePlayoffSpots(has2ndDivision);

                if (position <= playoffSpots && totalTeams >= 8) {
                    return {
                        type: 'playoffs',
                        description: 'Qualifica√ß√£o para play-offs'
                    };
                }

                return calculateRelegationProgression(
                    position,
                    totalTeams,
                    relegationRules,
                    hasMaintenancePlayoffs,
                    hasMaintenanceLeague
                );
            },

            _secondDivisionOnly: (context) => {
                const { position, hasMaintenancePlayoffs, hasMaintenanceLeague } = context;

                if (position === 1) {
                    return {
                        type: 'playoffs',
                        description: 'Play-offs + Promo√ß√£o'
                    };
                }

                if (position === 2) {
                    return calculatePromotionProgression(hasMaintenancePlayoffs, hasMaintenanceLeague);
                }

                return null;
            },

            _firstDivisionWithGroups: (context) => {
                const { position, totalTeams, structure,
                    hasMaintenancePlayoffs, hasMaintenanceLeague } = context;

                const secondDivisionGroups = structure.groups.filter(g =>
                    sampleData.teams.some(team => team.division === '2' && team.group === g)
                ).length;

                const playoffSpotsFrom1st = calculatePlayoffSpotsWithGroups(secondDivisionGroups, structure);

                if (position <= playoffSpotsFrom1st) {
                    return {
                        type: 'playoffs',
                        description: 'Qualifica√ß√£o para play-offs'
                    };
                }

                const relegationRules = getRelegationRules();
                return calculateRelegationProgression(
                    position,
                    totalTeams,
                    relegationRules,
                    hasMaintenancePlayoffs,
                    hasMaintenanceLeague
                );
            },

            _secondDivisionWithGroups: (context) => {
                const { position, hasMaintenancePlayoffs, hasMaintenanceLeague } = context;

                if (position === 1) {
                    return {
                        type: 'playoffs',
                        description: 'Play-offs + Promo√ß√£o'
                    };
                }

                if (position === 2) {
                    return calculatePromotionProgression(hasMaintenancePlayoffs, hasMaintenanceLeague);
                }

                return null;
            },

            _lowerDivisions: (context) => {
                // 3¬™ divis√£o ou inferior - primeiros 2 sobem
                if (context.position <= 2) {
                    return {
                        type: 'promotion',
                        description: 'Subida de divis√£o'
                    };
                }
                return null;
            }
        };

        // Fun√ß√µes auxiliares para c√°lculos espec√≠ficos
        function getRelegationRules() {
            const epochSelector = document.getElementById('epoca');
            const modalidadeSelector = document.getElementById('modalidade');

            if (!epochSelector || !modalidadeSelector) {
                console.warn('‚ö†Ô∏è getRelegationRules: seletores n√£o encontrados');
                return { directRelegation: 3, maintenancePosition: 1 };
            }

            const currentEpoch = epochSelector.value;
            const currentModality = modalidadeSelector.value;

            if (currentEpoch === '24_25') {
                if (currentModality && currentModality.includes('ANDEBOL')) {
                    return { directRelegation: 2, maintenancePosition: 0 };
                }
                return { directRelegation: 4, maintenancePosition: 0 };
            }

            if (currentModality && currentModality.includes('ANDEBOL')) {
                return { directRelegation: 2, maintenancePosition: 1 };
            }

            return { directRelegation: 3, maintenancePosition: 1 };
        }

        function calculatePlayoffSpots(has2ndDivision) {
            const epochSelector = document.getElementById('epoca');
            const modalidadeSelector = document.getElementById('modalidade');

            if (!epochSelector || !modalidadeSelector) {
                return 7;
            }

            const currentEpoch = epochSelector.value;
            const currentModality = modalidadeSelector.value;

            if (currentEpoch === '24_25') {
                return currentModality && currentModality.includes('ANDEBOL') ? 7 : 6;
            }

            if (currentModality && currentModality.includes('ANDEBOL')) {
                return 7;
            }

            return has2ndDivision ? 7 : 8;
        }

        function calculatePlayoffSpotsWithGroups(secondDivisionGroups, structure) {
            const epochSelector = document.getElementById('epoca');
            const currentEpoch = epochSelector ? epochSelector.value : null;

            if (currentEpoch === '24_25') {
                return calculatePlayoffSpots(false);
            }

            if (secondDivisionGroups === 0 && structure.divisions.includes('2')) {
                return 7;
            }

            return Math.max(4, 8 - secondDivisionGroups);
        }

        function calculateRelegationProgression(position, totalTeams, relegationRules, hasMaintenancePlayoffs, hasMaintenanceLeague) {
            const directRelegationStart = totalTeams - relegationRules.directRelegation + 1;
            const maintenanceStart = totalTeams - (relegationRules.directRelegation + relegationRules.maintenancePosition) + 1;

            if (position >= directRelegationStart) {
                return {
                    type: 'relegation',
                    description: 'Descida de divis√£o'
                };
            }

            if (relegationRules.maintenancePosition > 0 && position >= maintenanceStart) {
                if (hasMaintenancePlayoffs || hasMaintenanceLeague) {
                    return {
                        type: hasMaintenancePlayoffs ? 'maintenance-playoffs' : 'maintenance-league',
                        description: hasMaintenancePlayoffs ? 'Play-off de manuten√ß√£o' : 'Liguilha de manuten√ß√£o'
                    };
                }
            }

            return null;
        }

        function calculatePromotionProgression(hasMaintenancePlayoffs, hasMaintenanceLeague) {
            if (hasMaintenancePlayoffs) {
                return {
                    type: 'promotion-playoffs',
                    description: 'Play-off de Promo√ß√£o'
                };
            }

            if (hasMaintenanceLeague) {
                return {
                    type: 'promotion-league',
                    description: 'Liguilha de Promo√ß√£o'
                };
            }

            return {
                type: 'promotion',
                description: 'Subida de divis√£o'
            };
        }

        function checkTeamBQualification(teamName, position) {
            if (!teamName || !TeamUtils.isTeamB(teamName)) {
                return null;
            }

            const qualified = getQualifiedTeams();
            const isInPlayoffs = qualified.playoffs.some(t => t === teamName);
            const isInMaintenancePlayoff = qualified.maintenancePlayoff.some(t => t === teamName);
            const isInPromotionPlayoff = qualified.promotionPlayoff.some(t => t === teamName);

            if (!isInPlayoffs && !isInMaintenancePlayoff && !isInPromotionPlayoff) {
                DebugUtils.debugTeamBStatus('team_b_not_qualified', { team: teamName, position });
                return {
                    type: 'safe',
                    description: `Zona segura (${position}¬∫ lugar - equipa B n√£o qualifica)`
                };
            }

            DebugUtils.debugTeamBStatus('team_b_qualified', { team: teamName, position });
            return null;
        }

        function checkSubstituteQualification(teamName, position, isSecondDivision, hasMaintenancePlayoffs, hasMaintenanceLeague) {
            if (!teamName || TeamUtils.isTeamB(teamName) || !isSecondDivision || (position !== 2 && position < 3)) {
                return null;
            }

            const qualified = getQualifiedTeams();
            const isInPlayoffs = qualified.playoffs.some(t => t === teamName);

            if (isInPlayoffs && position > 1) {
                DebugUtils.debugTeamBStatus('in_playoffs_replaced', { team: teamName, position });
                return {
                    type: 'playoffs',
                    description: `Play-offs + Promo√ß√£o (substitui ${position}¬∫ do grupo)`
                };
            }

            const isInPromotionPlayoff = qualified.promotionPlayoff.some(t => t === teamName);

            if (isInPromotionPlayoff && position > 2) {
                DebugUtils.debugTeamBStatus('in_promotion_replaced', { team: teamName, position });

                if (hasMaintenancePlayoffs) {
                    return {
                        type: 'promotion-playoffs',
                        description: `Play-off de Promo√ß√£o (substitui ${position}¬∫ do grupo)`
                    };
                }

                if (hasMaintenanceLeague) {
                    return {
                        type: 'promotion-league',
                        description: `Liguilha de Promo√ß√£o (substitui ${position}¬∫ do grupo)`
                    };
                }

                return {
                    type: 'promotion',
                    description: `Subida de divis√£o (substitui ${position}¬∫ do grupo)`
                };
            }

            return null;
        }

        // Fun√ß√£o principal de progress√£o usando Strategy Pattern
        function getTeamProgression(position, totalTeams, structure, teamName = null, teamGroup = null) {
            DebugUtils.debugModalityAnalysis('calculating_progression', {
                position,
                totalTeams,
                structure: structure.type,
                divisions: structure.divisions,
                groups: structure.groups,
                currentDivision,
                currentGroup,
                playoffSystem: playoffSystemInfo,
                teamName,
                teamGroup
            });

            const divisionNum = parseInt(currentDivision) || 1;
            const isSecondDivision = divisionNum === 2;
            const hasWinnerPlayoffs = playoffSystemInfo.hasWinnerPlayoffs || false;
            const hasMaintenancePlayoffs = playoffSystemInfo.hasMaintenancePlayoffs || false;
            const hasMaintenanceLeague = playoffSystemInfo.hasMaintenanceLeague || false;

            // Verificar qualifica√ß√£o de equipa B
            const teamBResult = checkTeamBQualification(teamName, position);
            if (teamBResult) return teamBResult;

            // Verificar equipa substituta
            const substituteResult = checkSubstituteQualification(
                teamName,
                position,
                isSecondDivision,
                hasMaintenancePlayoffs,
                hasMaintenanceLeague
            );
            if (substituteResult) return substituteResult;

            // Criar contexto para a estrat√©gia
            const context = {
                position,
                totalTeams,
                structure,
                divisionNum,
                isSecondDivision,
                hasWinnerPlayoffs,
                hasMaintenancePlayoffs,
                hasMaintenanceLeague,
                teamName,
                teamGroup
            };

            // Selecionar e executar estrat√©gia apropriada
            const strategy = progressionStrategies[structure.type];
            if (!strategy) {
                console.warn(`‚ö†Ô∏è Estrat√©gia n√£o encontrada para tipo: ${structure.type}`);
                return { type: 'safe', description: 'Zona segura' };
            }

            const result = strategy(context);
            return result || { type: 'safe', description: 'Zona segura' };
        }

        // ==================== FIM DO STRATEGY PATTERN ====================

        function analyzeModalityStructure() {
            const structure = {
                hasDivisions: false,
                hasGroups: false,
                divisions: [],
                groups: [],
                type: 'unknown'
            };

            DebugUtils.debugModalityAnalysis('analyzing_structure');
            DebugUtils.debugModalityAnalysis('rankings_available', Object.keys(sampleData.rankings));

            // Verificar estrutura baseada nos dados de classifica√ß√£o
            Object.keys(sampleData.rankings).forEach(key => {
                // Detectar divis√µes: "1¬™ Divis√£o", "2¬™ Divis√£o", "1", "2"
                if (key.includes('Divis√£o') || key.match(/^[12][¬™a]?\s*(div|divis√£o)?$/i) || ['1', '2'].includes(key)) {
                    structure.hasDivisions = true;
                    if (!structure.divisions.includes(key)) {
                        structure.divisions.push(key);
                    }
                }

                // Detectar grupos: "2¬™ Divis√£o - Grupo A", ou qualquer chave com "Grupo"
                if (key.includes('Grupo') || key.match(/grupo\s+[A-Z]/i)) {
                    structure.hasGroups = true;
                    if (!structure.groups.includes(key)) {
                        structure.groups.push(key);
                    }
                }

                // "geral" √© liga √∫nica
                if (key === 'geral') {
                    structure.type = 'single-league';
                }
            });

            // Verificar grupos dentro das equipas para casos especiais
            const groupsInTeams = new Set();
            sampleData.teams.forEach(team => {
                if (team.group && team.group !== team.division) {
                    groupsInTeams.add(team.group);
                }
            });

            if (groupsInTeams.size > 0) {
                structure.hasGroups = true;
                groupsInTeams.forEach(group => {
                    if (!structure.groups.includes(group)) {
                        structure.groups.push(group);
                    }
                });
            }

            // Determinar tipo de estrutura
            if (structure.hasDivisions && structure.hasGroups) {
                structure.type = 'divisions-and-groups'; // Ex: Futsal Masculino
            } else if (structure.hasDivisions) {
                structure.type = 'divisions-only'; // Ex: Andebol
            } else if (structure.hasGroups) {
                structure.type = 'groups-only'; // Ex: Futsal Feminino 24_25 (2 grupos)
            } else if (Object.keys(sampleData.rankings).length === 1 && Object.keys(sampleData.rankings)[0] === 'geral') {
                structure.type = 'single-league'; // Ex: Basquetebol Feminino 25_26, Futsal Feminino 25_26 (liga √∫nica)
            }

            DebugUtils.debugModalityAnalysis('structure_detected', structure);
            return structure;
        }

        // Fun√ß√£o auxiliar para ativar s√≥ certas equipas
        function setActiveTeams(teamNames) {
            const checkboxes = document.querySelectorAll('#teamSelector input[type="checkbox"]');
            checkboxes.forEach((checkbox, index) => {
                const label = checkbox.parentElement;
                if (teamNames.includes(sampleData.teams[index].name)) {
                    checkbox.checked = true;
                    label.classList.add('active');
                } else {
                    checkbox.checked = false;
                    label.classList.remove('active');
                }
            });
            updateEloChart();
            updateTeamCountIndicator();
        }

        // Filtro Top 3 - equipas que chegaram √† final e vencedor do 3¬∫ lugar
        function filterTop3() {
            const top3Teams = new Set();

            // Procurar nos dados do bracket se existir
            if (sampleData.bracket && Object.keys(sampleData.bracket).length > 0) {
                // Adicionar finalistas
                if (sampleData.bracket["Final"]) {
                    sampleData.bracket["Final"].forEach(match => {
                        top3Teams.add(match.team1);
                        top3Teams.add(match.team2);
                    });
                }

                // Adicionar vencedor do 3¬∫ lugar
                if (sampleData.bracket["3¬∫ Lugar"]) {
                    sampleData.bracket["3¬∫ Lugar"].forEach(match => {
                        top3Teams.add(match.winner);
                    });
                }
            }

            // Se n√£o h√° dados do bracket ou n√£o encontrou 3 equipas, usar ranking
            if (top3Teams.size < 3) {
                DebugUtils.debugBracket('using_ranking_fallback');
                const rankingTop3 = sampleData.rankings[currentDivision].slice(0, 3).map(t => t.team);
                setActiveTeams(rankingTop3);
            } else {
                DebugUtils.debugPlayoffs('top3_teams', [...top3Teams]);
                setActiveTeams([...top3Teams]);
            }
        }

        // Filtro por divis√£o
        function filterDivision(division) {
            if (!sampleData.rankings[division]) return;
            const divisionTeams = sampleData.rankings[division].map(t => t.team);
            setActiveTeams(divisionTeams);
        }

        // Filtro por grupo
        function filterGroup(group) {
            const groupTeams = [];
            // Procurar em todas as divis√µes por equipas do grupo especificado
            Object.values(sampleData.rankings).forEach(divisionTeams => {
                divisionTeams.forEach(team => {
                    if (team.group === group) {
                        groupTeams.push(team.team);
                    }
                });
            });
            setActiveTeams(groupTeams);
        }

        // Filtro equipas que passaram aos playoffs (est√£o no bracket)
        function filterPlayoffs() {
            const playoffTeams = new Set();

            // Usar dados brutos para encontrar equipas nos playoffs
            if (sampleData.rawEloData && sampleData.rawEloData.length > 0) {
                sampleData.rawEloData.forEach(match => {
                    if (match.Jornada && match.Jornada.startsWith('E')) {
                        if (match["Equipa 1"]) playoffTeams.add(match["Equipa 1"]);
                        if (match["Equipa 2"]) playoffTeams.add(match["Equipa 2"]);
                    }
                });
            } else {
                // Fallback para usar dados do bracket se dispon√≠vel
                Object.values(sampleData.bracket).forEach(round =>
                    round.forEach(match => {
                        playoffTeams.add(match.team1);
                        playoffTeams.add(match.team2);
                    })
                );
            }

            DebugUtils.debugPlayoffs('playoff_teams', [...playoffTeams]);
            setActiveTeams([...playoffTeams]);
        }

        // Resetar filtro -> ativa todas as equipas
        function resetFilter() {
            const checkboxes = document.querySelectorAll('#teamSelector input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                const label = checkbox.parentElement;
                checkbox.checked = true;
                label.classList.add('active');
            });
            updateEloChart();
        }

        // Configura√ß√£o dos cursos carregada de ficheiro externo
        let coursesConfig = {};

        /**
         * Carrega a configura√ß√£o dos cursos do ficheiro JSON
         */
        async function loadCoursesConfig() {
            try {
                const response = await fetch('config_cursos.json');
                if (!response.ok) {
                    throw new Error('Erro ao carregar config_cursos.json');
                }
                const data = await response.json();
                coursesConfig = data.courses;
                DebugUtils.debugFileLoading('courses_loaded', { count: Object.keys(coursesConfig).length });
            } catch (error) {
                console.error('Erro ao carregar configura√ß√£o de cursos:', error);
            }
        }

        /**
         * Normaliza texto removendo acentos e convertendo para min√∫sculas
         */
        function normalizeText(text) {
            return text.toLowerCase()
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '')
                .trim();
        }

        /**
         * Normaliza nomes de equipas para resolver duplica√ß√µes
         */
        function normalizeTeamName(teamName) {
            if (!teamName) return teamName;

            let normalized = teamName.trim();

            // Casos espec√≠ficos conhecidos
            if (normalized === 'Tradu√ßao' || normalized === 'TRADU√á√ÉO' || normalized === 'TRADU√áAO' ||
                normalized.toLowerCase() === 'tradu√ß√£o' || normalized.toLowerCase() === 'tradu√ßao') {
                normalized = 'Tradu√ß√£o';
            }

            // Normaliza√ß√£o adicional removendo acentos
            const withoutAccents = normalizeText(normalized);
            if (withoutAccents === 'traducao') {
                normalized = 'Tradu√ß√£o';
            }

            return normalized;
        }

        /**
         * Obt√©m as informa√ß√µes de um curso pelo nome
         * @param {string} courseName Nome do curso
         * @returns {object} Informa√ß√µes do curso (nome completo, n√∫cleo, emblema, cores)
         */
        function getCourseInfo(courseName) {
            let courseKey = courseName.trim();

            // Normaliza√ß√£o espec√≠fica para cursos com varia√ß√µes de grafia
            if (courseKey === 'Tradu√ßao' || courseKey === 'TRADU√á√ÉO' || courseKey === 'TRADU√áAO' ||
                courseKey.toLowerCase() === 'tradu√ß√£o' || courseKey.toLowerCase() === 'tradu√ßao') {
                courseKey = 'Tradu√ß√£o';
            }

            // Normaliza√ß√£o adicional para casos de varia√ß√µes de acentos
            const normalizedInput = normalizeText(courseKey);
            if (normalizedInput === 'traducao') {
                courseKey = 'Tradu√ß√£o';
            }

            // CORRIGIDO: Acessar coursesConfig.courses ao inv√©s de coursesConfig diretamente
            const courseInfo = coursesConfig.courses ? coursesConfig.courses[courseKey] : coursesConfig[courseKey];

            if (courseInfo) {
                return {
                    shortName: courseKey,
                    fullName: courseInfo.displayName || courseKey,
                    nucleus: courseInfo.nucleus,
                    emblemPath: courseInfo.emblem,
                    colors: courseInfo.colors, // Retornar o array completo
                    primaryColor: courseInfo.colors[0],
                    secondaryColor: courseInfo.colors[1]
                };
            }

            // Fallback para cursos n√£o configurados - usar emblema padr√£o da UA
            return {
                shortName: courseKey,
                fullName: courseKey,
                nucleus: 'UA',
                emblemPath: 'assets/ta√ßa_ua.png',
                primaryColor: generateFallbackColor(courseKey),
                secondaryColor: generateFallbackColor(courseKey, true)
            };
        }

        /**
         * Gera uma cor baseada no hash do nome do curso
         * @param {string} courseName Nome do curso
         * @param {boolean} lighter Se deve gerar uma cor mais clara
         * @returns {string} Cor em formato hex
         */
        function generateFallbackColor(courseName, lighter = false) {
            let hash = 0;
            for (let i = 0; i < courseName.length; i++) {
                hash = courseName.charCodeAt(i) + ((hash << 5) - hash);
            }

            const hue = Math.abs(hash) % 360;
            const saturation = lighter ? 50 : 70;
            const lightness = lighter ? 70 : 50;

            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }

        /**
         * Obt√©m todas as configura√ß√µes de cursos
         * @returns {object} Objeto com todas as configura√ß√µes de cursos
         */
        function getAllCoursesConfig() {
            return coursesConfig;
        }

        // ==================== ESTADO CENTRALIZADO DA APLICA√á√ÉO ====================
        const appState = {
            // Estado do gr√°fico ELO
            chart: {
                instance: null,
                pan: {
                    enabled: false,
                    isPanning: false,
                    startX: 0,
                    startY: 0
                }
            },

            // Estado da visualiza√ß√£o atual
            view: {
                division: 'A',
                group: null,
                hasAdjustments: false
            },

            // Estado do calend√°rio
            calendar: {
                jornada: null,
                division: null,
                group: null
            },

            // Dados carregados
            data: {
                teams: [],
                rankings: {},
                eloHistory: {},
                matches: [],
                bracket: {},
                secondaryBracket: {},
                secondaryBracketType: null,
                gamesDates: [],
                rawEloData: []
            },

            // Sele√ß√£o atual
            selection: {
                epoca: null,
                modalidade: null,
                availableEpocas: [],
                playoffSystemInfo: {}
            }
        };

        // ==================== COMPATIBILIDADE COM C√ìDIGO LEGADO ====================
        // Proxies para sincronizar vari√°veis antigas com appState

        // Proxy para sampleData
        let sampleData = new Proxy(appState.data, {
            get(target, prop) {
                return target[prop];
            },
            set(target, prop, value) {
                target[prop] = value;
                return true;
            }
        });

        // Getters/Setters para vari√°veis de sele√ß√£o
        Object.defineProperty(window, 'currentEpoca', {
            get: () => appState.selection.epoca,
            set: (value) => { appState.selection.epoca = value; }
        });

        Object.defineProperty(window, 'currentModalidade', {
            get: () => appState.selection.modalidade,
            set: (value) => { appState.selection.modalidade = value; }
        });

        Object.defineProperty(window, 'availableEpocas', {
            get: () => appState.selection.availableEpocas,
            set: (value) => { appState.selection.availableEpocas = value; }
        });

        Object.defineProperty(window, 'playoffSystemInfo', {
            get: () => appState.selection.playoffSystemInfo,
            set: (value) => { appState.selection.playoffSystemInfo = value; }
        });

        // Getters/Setters para vari√°veis do calend√°rio
        Object.defineProperty(window, 'currentCalendarJornada', {
            get: () => appState.calendar.jornada,
            set: (value) => { appState.calendar.jornada = value; }
        });

        Object.defineProperty(window, 'currentCalendarDivision', {
            get: () => appState.calendar.division,
            set: (value) => { appState.calendar.division = value; }
        });

        Object.defineProperty(window, 'currentCalendarGroup', {
            get: () => appState.calendar.group,
            set: (value) => { appState.calendar.group = value; }
        });

        // Getters/Setters para vari√°veis de visualiza√ß√£o
        Object.defineProperty(window, 'currentDivision', {
            get: () => appState.view.division,
            set: (value) => { appState.view.division = value; }
        });

        Object.defineProperty(window, 'currentGroup', {
            get: () => appState.view.group,
            set: (value) => { appState.view.group = value; }
        });

        Object.defineProperty(window, 'currentModalityHasAdjustments', {
            get: () => appState.view.hasAdjustments,
            set: (value) => { appState.view.hasAdjustments = value; }
        });

        // Getters/Setters para vari√°veis do gr√°fico
        Object.defineProperty(window, 'eloChart', {
            get: () => appState.chart.instance,
            set: (value) => { appState.chart.instance = value; }
        });

        // Fun√ß√£o para detectar √©pocas dispon√≠veis baseadas nos arquivos existentes
        async function detectAvailableEpocas() {
            // √âpocas conhecidas (n√£o fazer requests para √©pocas futuras)
            const knownEpocas = ['24_25', '25_26'];

            // Ordenar √©pocas por ano (mais recente primeiro)
            const sortedEpocas = knownEpocas.sort((a, b) => {
                const [yearA] = a.split('_').map(n => parseInt(n));
                const [yearB] = b.split('_').map(n => parseInt(n));
                return yearB - yearA; // Ordem decrescente
            });

            DebugUtils.debugFileLoading('epochs_detected', { epochs: sortedEpocas });
            return sortedEpocas;
        }

        // Fun√ß√£o para obter modalidades dispon√≠veis para uma √©poca espec√≠fica
        function getModalidadesForEpoca(epoca) {
            const modalidades = [
                { value: 'ANDEBOL MISTO', label: 'Andebol Misto' },
                { value: 'BASQUETEBOL FEMININO', label: 'Basquetebol Feminino' },
                { value: 'BASQUETEBOL MASCULINO', label: 'Basquetebol Masculino' },
                { value: 'FUTEBOL DE 7 MASCULINO', label: 'Futebol 7 Masculino' },
                { value: 'FUTSAL FEMININO', label: 'Futsal Feminino' },
                { value: 'FUTSAL MASCULINO', label: 'Futsal Masculino' },
                { value: 'VOLEIBOL FEMININO', label: 'Voleibol Feminino' },
                { value: 'VOLEIBOL MASCULINO', label: 'Voleibol Masculino' }
            ];

            // Adicionar a √©poca ao final de cada modalidade
            return modalidades.map(mod => ({
                value: `${mod.value}_${epoca}`,
                label: mod.label
            }));
        }

        // Fun√ß√£o para inicializar os seletores
        async function initializeSelectors() {
            // Detectar √©pocas dispon√≠veis
            availableEpocas = await detectAvailableEpocas();

            // Definir √©poca atual como a mais recente (primeira do array ordenado)
            if (!currentEpoca && availableEpocas.length > 0) {
                currentEpoca = availableEpocas[0];
                DebugUtils.debugFileLoading('default_epoch_set', { epoch: currentEpoca });
            }

            // Preencher seletor de √©poca
            const epocaSelect = document.getElementById('epoca');
            epocaSelect.innerHTML = '';

            availableEpocas.forEach(epoca => {
                const option = document.createElement('option');
                option.value = epoca;
                option.textContent = `20${epoca.replace('_', '/')}`; // Converter 24_25 para 2024/25
                if (epoca === currentEpoca) {
                    option.selected = true;
                }
                epocaSelect.appendChild(option);
            });

            // Preencher seletor de modalidade
            updateModalidadeSelector();
        }

        // Fun√ß√£o para atualizar o seletor de modalidade baseado na √©poca
        function updateModalidadeSelector() {
            const modalidadeSelect = document.getElementById('modalidade');
            modalidadeSelect.innerHTML = '';

            const modalidades = getModalidadesForEpoca(currentEpoca);

            // Tentar preservar modalidade atual se existir na nova √©poca
            let modalidadeToLoad = null;

            // Extrair o nome da modalidade atual sem a √©poca (ex: "FUTSAL MASCULINO_25_26" -> "FUTSAL MASCULINO")
            let currentModalidadeName = null;
            if (currentModalidade) {
                currentModalidadeName = currentModalidade.replace(/_\d{2}_\d{2}$/, '');
            }

            modalidades.forEach((mod, index) => {
                const option = document.createElement('option');
                option.value = mod.value;
                option.textContent = mod.label;

                // Verificar se esta modalidade corresponde √† atual
                const modName = mod.value.replace(/_\d{2}_\d{2}$/, '');

                if (currentModalidadeName && modName === currentModalidadeName) {
                    // Preservar modalidade atual se existir na nova √©poca
                    option.selected = true;
                    modalidadeToLoad = mod.value;
                } else if (!modalidadeToLoad && mod.value.includes('FUTSAL MASCULINO')) {
                    // Usar Futsal Masculino como fallback
                    option.selected = true;
                    modalidadeToLoad = mod.value;
                }

                modalidadeSelect.appendChild(option);
            });

            // Carregar a modalidade selecionada
            if (modalidadeToLoad) {
                changeModalidade(modalidadeToLoad);
            }
        }

        // Fun√ß√£o para trocar √©poca
        function changeEpoca(epoca) {
            if (!epoca || epoca === currentEpoca) return;

            currentEpoca = epoca;
            updateModalidadeSelector();
        }

        function changeModalidade(mod) {
            if (!mod) return;

            // Atualizar modalidade atual
            currentModalidade = mod;

            // Caminhos relativos
            const classificacaoPath = `elo_ratings/classificacao_${mod}.csv`;
            const detalhePath = `elo_ratings/detalhe_${mod}.csv`;
            const eloPath = `elo_ratings/elo_${mod}.csv`;
            const jogosPath = `csv_modalidades/${mod}.csv`;

            // Reset dos dados e vari√°veis globais
            sampleData = {
                teams: [],
                rankings: {},
                eloHistory: {},
                matches: [],
                bracket: {},
                secondaryBracket: {},  // ‚Üê ADICIONADO para playoffs/liguilhas secund√°rios
                secondaryBracketType: null,  // ‚Üê ADICIONADO para tipo do bracket secund√°rio
                gamesDates: [],
                rawEloData: [],
                totalRegularSeasonGames: 0  // ‚Üê ADICIONADO para n√∫mero de jornadas do calend√°rio
            };
            currentModalityHasAdjustments = false;

            // Vari√°vel para guardar ELOs iniciais (usada quando detalhe_*.csv est√° vazio)
            let initialElosFromFile = {};

            // Mostrar loading
            document.getElementById('teamSelector').innerHTML = '<div class="loading"><div class="spinner"></div>A carregar dados...</div>';
            document.getElementById('rankingsBody').innerHTML = '<tr><td colspan="11" class="loading">A carregar classifica√ß√£o...</td></tr>';

            let loadedFiles = 0;
            const totalFiles = 4; // Agora s√£o 4 ficheiros

            function checkAllLoaded() {
                loadedFiles++;
                DebugUtils.debugFileLoading('file_loaded', { current: loadedFiles, total: totalFiles });
                if (loadedFiles === totalFiles) {
                    DebugUtils.debugFileLoading('all_files_loaded', sampleData);
                    // Todos os arquivos carregados, atualizar interface
                    setTimeout(() => {
                        createTeamSelector();
                        createDivisionSelector();
                        updateQuickFilters(); // Atualizar filtros baseados na estrutura
                        updateRankingsTable();
                        initializeCalendarSelectors(); // Inicializar calend√°rio
                        if (eloChart) {
                            updateEloChart();
                        }
                        // Brackets ser√£o carregados depois de processar rankings
                    }, 500);
                }
            }

            // Carregar CSVs
            Papa.parse(classificacaoPath, {
                download: true,
                header: true,
                complete: results => {
                    processRankings(results.data);
                    checkAllLoaded();
                },
                error: error => {
                    console.error('Erro ao carregar classifica√ß√£o:', error);
                    checkAllLoaded();
                }
            });

            Papa.parse(jogosPath, {
                download: true,
                header: true,
                complete: results => {
                    processMatches(results.data);
                    checkAllLoaded();
                },
                error: error => {
                    console.error('Erro ao carregar jogos:', error);
                    checkAllLoaded();
                }
            });

            // Carregar ficheiro elo_*.csv com ELOs iniciais PRIMEIRO
            Papa.parse(eloPath, {
                download: true,
                header: false, // Sem cabe√ßalho - primeira linha √© nomes, segunda √© valores
                complete: results => {
                    if (results.data && results.data.length >= 2) {
                        const teams = results.data[0]; // Primeira linha: nomes das equipas
                        const elos = results.data[1];  // Segunda linha: valores ELO

                        // Criar mapa equipa -> ELO inicial
                        teams.forEach((team, index) => {
                            if (team && elos[index]) {
                                const normalizedTeam = normalizeTeamName(team);
                                initialElosFromFile[normalizedTeam] = parseFloat(elos[index]);
                            }
                        });

                        DebugUtils.debugFileLoading('initial_elos_loaded', initialElosFromFile);
                    }

                    checkAllLoaded();

                    // AGORA SIM carregar detalhe (s√≥ depois de ter os ELOs iniciais)
                    Papa.parse(detalhePath, {
                        download: true,
                        header: true,
                        skipEmptyLines: true,
                        newline: '\n',
                        complete: results => {
                            processEloHistory(results.data, initialElosFromFile);
                            checkAllLoaded();
                        },
                        error: error => {
                            console.error('Erro ao carregar detalhes ELO:', error);
                            checkAllLoaded();
                        }
                    });
                },
                error: error => {
                    console.error('Erro ao carregar ELOs iniciais:', error);
                    checkAllLoaded();
                }
            });
        }

        // ========== FUN√á√ïES DO CALEND√ÅRIO DE JOGOS ==========

        // Vari√°veis globais para controle do calend√°rio
        let availableJornadas = [];

        // Inicializar seletores do calend√°rio
        function initializeCalendarSelectors() {
            const jornadaTitle = document.getElementById('jornadaTitle');
            const prevBtn = document.getElementById('prevJornadaBtn');
            const nextBtn = document.getElementById('nextJornadaBtn');
            const divisionSelectorDiv = document.getElementById('calendarDivisionSelector');
            const groupSelectorDiv = document.getElementById('calendarGroupSelector');            // Guardar jornada atual antes de limpar
            const previousJornada = currentCalendarJornada;

            // Limpar seletores
            divisionSelectorDiv.innerHTML = '';
            groupSelectorDiv.innerHTML = '';

            // Verificar se h√° jogos dispon√≠veis (usar matches, n√£o rawEloData)
            if (!sampleData.matches || sampleData.matches.length === 0) {
                jornadaTitle.textContent = 'Sem jogos dispon√≠veis';
                prevBtn.disabled = true;
                nextBtn.disabled = true;
                divisionSelectorDiv.style.display = 'none';
                groupSelectorDiv.style.display = 'none';
                return;
            }

            // Verificar se h√° divis√µes/grupos nos dados dos jogos
            const hasDivisions = sampleData.rankings && Object.keys(sampleData.rankings).length > 0;
            const structure = analyzeModalityStructure();

            // Criar seletores IGUAIS √† classifica√ß√£o
            if (hasDivisions && structure.type !== 'single-league') {
                createCalendarDivisionSelector();
            } else {
                divisionSelectorDiv.style.display = 'none';
                currentCalendarDivision = null;
            }

            // N√£o h√° seletor de grupo separado - j√° est√° inclu√≠do na divis√£o ("2¬™ Divis√£o - Grupo A")
            groupSelectorDiv.style.display = 'none';
            currentCalendarGroup = null;

            // Atualizar jornadas dispon√≠veis para a divis√£o/grupo atual
            updateAvailableJornadas();

            // Tentar manter a mesma jornada, ou usar a primeira se n√£o existir
            if (availableJornadas.length > 0) {
                // Se havia uma jornada anterior e ela existe na nova √©poca, manter
                if (previousJornada && availableJornadas.includes(previousJornada)) {
                    currentCalendarJornada = previousJornada;
                } else {
                    // Caso contr√°rio, usar a primeira jornada
                    currentCalendarJornada = availableJornadas[0];
                }
                updateJornadaDisplay();
            } else {
                jornadaTitle.textContent = 'Sem jornadas dispon√≠veis';
                prevBtn.disabled = true;
                nextBtn.disabled = true;
            }

            // Atualizar calend√°rio com a jornada selecionada
            updateCalendar();

            // Garantir que os bot√µes da classifica√ß√£o estejam sincronizados visualmente
            updateRankingsDivisionButtons();
            if (currentGroup) {
                updateRankingsGroupButtons();
            }
        }

        // Atualizar jornadas dispon√≠veis para divis√£o/grupo atual
        function updateAvailableJornadas() {
            // Extrair divis√£o num√©rica e grupo do label formatado
            let targetDivision = null;
            let targetGroup = null;

            if (currentCalendarDivision) {
                const divMatch = currentCalendarDivision.match(/^(\d+)¬™ Divis√£o(?:\s*-\s*Grupo\s*([A-Z]))?$/);
                if (divMatch) {
                    targetDivision = divMatch[1]; // "1" ou "2"
                    targetGroup = divMatch[2] || null; // "A", "B", "C" ou null
                }
            }

            // Filtrar jornadas para a divis√£o/grupo atual
            let filteredMatches = sampleData.matches.filter(match => {
                if (!match.jornada || isNaN(parseInt(match.jornada))) return false;

                // Se h√° divis√£o selecionada, filtrar por ela
                if (targetDivision) {
                    const matchDiv = match.division ? match.division.toString() : null;
                    const matchGroup = match.grupo || null;

                    // Comparar divis√£o
                    const divMatch = matchDiv && (matchDiv == targetDivision ||
                        parseFloat(matchDiv) == parseFloat(targetDivision));
                    if (!divMatch) return false;

                    // Se tem grupo no label, filtrar por grupo tamb√©m
                    if (targetGroup && matchGroup !== targetGroup) return false;
                }

                return true;
            });

            // Obter jornadas √∫nicas e ordenadas
            availableJornadas = [...new Set(
                filteredMatches.map(match => parseInt(match.jornada))
            )].sort((a, b) => a - b);
        }

        // Criar seletor de divis√£o (IGUAL √† classifica√ß√£o - usa sampleData.rankings)
        function createCalendarDivisionSelector() {
            const divisionSelectorDiv = document.getElementById('calendarDivisionSelector');

            if (!sampleData.rankings || Object.keys(sampleData.rankings).length === 0) {
                divisionSelectorDiv.style.display = 'none';
                return;
            }

            const structure = analyzeModalityStructure();
            const divisions = Object.keys(sampleData.rankings); // Labels formatados: "1¬™ Divis√£o", "2¬™ Divis√£o - Grupo A"

            // Se for liga √∫nica, ocultar o seletor
            if (structure.type === 'single-league') {
                divisionSelectorDiv.style.display = 'none';
                return;
            }

            divisionSelectorDiv.style.display = 'flex';
            divisionSelectorDiv.innerHTML = '';

            // Sincronizar com divis√£o atual da classifica√ß√£o ou usar primeira
            if (!currentCalendarDivision || !divisions.includes(currentCalendarDivision)) {
                currentCalendarDivision = currentDivision || divisions[0];
            }

            divisions.forEach(div => {
                const btn = document.createElement('button');
                btn.className = `division-btn ${div === currentCalendarDivision ? 'active' : ''}`;
                btn.textContent = div; // Label j√° vem formatado: "1¬™ Divis√£o" ou "2¬™ Divis√£o - Grupo A"
                btn.onclick = () => switchCalendarDivision(div);
                divisionSelectorDiv.appendChild(btn);
            });
        }

        // Criar seletor de grupo (IGUAL √† classifica√ß√£o - usa sampleData.rankings)
        function createCalendarGroupSelector() {
            const groupSelectorDiv = document.getElementById('calendarGroupSelector');

            if (!sampleData.rankings || !sampleData.rankings[currentCalendarDivision]) {
                groupSelectorDiv.style.display = 'none';
                return;
            }

            // Obter grupos √∫nicos para a divis√£o atual
            const teams = sampleData.rankings[currentCalendarDivision];
            const groups = [...new Set(teams.map(team => team.group))].filter(group => group && group !== 'nan');

            if (groups.length <= 1) {
                groupSelectorDiv.style.display = 'none';
                currentCalendarGroup = null;
                return;
            }

            // Mostrar seletor de grupos se h√° m√∫ltiplos grupos
            groupSelectorDiv.style.display = 'flex';
            groupSelectorDiv.innerHTML = '';

            // Sincronizar com grupo da classifica√ß√£o, ou usar Grupo A, ou primeiro dispon√≠vel
            if (currentCalendarGroup === null || !groups.includes(currentCalendarGroup)) {
                // Tentar usar grupo atual da classifica√ß√£o
                if (currentGroup && groups.includes(currentGroup)) {
                    currentCalendarGroup = currentGroup;
                } else if (groups.includes('A')) {
                    currentCalendarGroup = 'A';
                } else {
                    currentCalendarGroup = groups[0];
                }
            }

            // Bot√µes de grupos espec√≠ficos
            groups.forEach(group => {
                const btn = document.createElement('button');
                btn.className = `group-btn ${group === currentCalendarGroup ? 'active' : ''}`;
                btn.textContent = `Grupo ${group}`;
                btn.onclick = () => switchCalendarGroup(group);
                groupSelectorDiv.appendChild(btn);
            });
        }

        // Trocar divis√£o no calend√°rio
        function switchCalendarDivision(division) {
            currentCalendarDivision = division;

            // Atualizar bot√µes de divis√£o do calend√°rio
            document.querySelectorAll('#calendarDivisionSelector .division-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            // Sincronizar com a classifica√ß√£o
            currentDivision = division;
            currentGroup = null; // Reset group quando muda divis√£o

            // Atualizar bot√µes da classifica√ß√£o
            updateRankingsDivisionButtons();
            updateGroupSelector(); // Recria os bot√µes de grupo se necess√°rio
            updateRankingsTable();

            // Atualizar jornadas dispon√≠veis para nova divis√£o/grupo
            updateAvailableJornadas();

            // Ajustar jornada atual se exceder o m√°ximo da nova divis√£o/grupo
            if (availableJornadas.length > 0) {
                if (!availableJornadas.includes(currentCalendarJornada)) {
                    // Se a jornada atual n√£o existe nesta divis√£o, ir para a √∫ltima dispon√≠vel
                    currentCalendarJornada = availableJornadas[availableJornadas.length - 1];
                }
                updateJornadaDisplay();
            } else {
                currentCalendarJornada = null;
            }

            // Atualizar calend√°rio
            updateCalendar();
        }

        // Trocar grupo no calend√°rio (n√£o usado - grupos integrados na divis√£o)
        function switchCalendarGroup(group) {
            currentCalendarGroup = group;

            // Atualizar bot√µes de grupo do calend√°rio
            document.querySelectorAll('#calendarGroupSelector .group-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            // Sincronizar com a classifica√ß√£o
            currentGroup = group;

            // Atualizar bot√µes da classifica√ß√£o
            updateRankingsGroupButtons();
            updateRankingsTable();

            // Atualizar jornadas dispon√≠veis para novo grupo
            updateAvailableJornadas();

            // Ajustar jornada atual se exceder o m√°ximo do novo grupo
            if (availableJornadas.length > 0) {
                if (!availableJornadas.includes(currentCalendarJornada)) {
                    currentCalendarJornada = availableJornadas[availableJornadas.length - 1];
                }
                updateJornadaDisplay();
            } else {
                currentCalendarJornada = null;
            }

            // Atualizar calend√°rio
            updateCalendar();
        }        // Mudar jornada (navega√ß√£o com setas)
        function changeJornada(direction) {
            if (availableJornadas.length === 0) return;

            const currentIndex = availableJornadas.indexOf(currentCalendarJornada);
            const newIndex = currentIndex + direction;

            // Se est√° dentro do range de jornadas, navegar normalmente
            if (newIndex >= 0 && newIndex < availableJornadas.length) {
                currentCalendarJornada = availableJornadas[newIndex];
                updateJornadaDisplay();
                updateCalendar();
            }
            // Se chegou ao limite, verificar se pode mudar de √©poca
            else if (newIndex < 0) {
                // Tentar ir para √©poca anterior
                switchToPreviousEpoca();
            } else if (newIndex >= availableJornadas.length) {
                // Tentar ir para pr√≥xima √©poca
                switchToNextEpoca();
            }
        }

        // Mudar para √©poca anterior (√∫ltima jornada)
        function switchToPreviousEpoca() {
            const currentEpochElement = document.getElementById('epoca');
            if (!currentEpochElement) return;

            const currentEpoch = currentEpochElement.value;
            const currentIndex = availableEpocas.indexOf(currentEpoch);

            // availableEpocas est√° em ordem decrescente: ['25_26', '24_25']
            // √©poca anterior √© o pr√≥ximo √≠ndice
            if (currentIndex < availableEpocas.length - 1) {
                const previousEpoch = availableEpocas[currentIndex + 1];

                // Atualizar o select de √©poca
                currentEpochElement.value = previousEpoch;

                // Chamar changeEpoca para atualizar todos os dados
                changeEpoca(previousEpoch);

                // Ap√≥s mudan√ßa, ir para √∫ltima jornada dispon√≠vel
                setTimeout(() => {
                    if (availableJornadas.length > 0) {
                        currentCalendarJornada = availableJornadas[availableJornadas.length - 1];
                        updateJornadaDisplay();
                        updateCalendar();
                    }
                }, 100);
            }
        }

        // Mudar para pr√≥xima √©poca (primeira jornada)
        function switchToNextEpoca() {
            const currentEpochElement = document.getElementById('epoca');
            if (!currentEpochElement) return;

            const currentEpoch = currentEpochElement.value;
            const currentIndex = availableEpocas.indexOf(currentEpoch);

            // availableEpocas est√° em ordem decrescente: ['25_26', '24_25']
            // pr√≥xima √©poca √© o √≠ndice anterior
            if (currentIndex > 0) {
                const nextEpoch = availableEpocas[currentIndex - 1];

                // Atualizar o select de √©poca
                currentEpochElement.value = nextEpoch;

                // Chamar changeEpoca para atualizar todos os dados
                changeEpoca(nextEpoch);

                // Ap√≥s mudan√ßa, ir para primeira jornada dispon√≠vel
                setTimeout(() => {
                    if (availableJornadas.length > 0) {
                        currentCalendarJornada = availableJornadas[0];
                        updateJornadaDisplay();
                        updateCalendar();
                    }
                }, 100);
            }
        }

        // Atualizar display da jornada e bot√µes
        function updateJornadaDisplay() {
            const jornadaTitle = document.getElementById('jornadaTitle');
            const prevBtn = document.getElementById('prevJornadaBtn');
            const nextBtn = document.getElementById('nextJornadaBtn');
            const prevEpocaLabel = document.getElementById('prevEpocaLabel');
            const nextEpocaLabel = document.getElementById('nextEpocaLabel');

            jornadaTitle.textContent = `Jornada ${currentCalendarJornada}`;

            const currentIndex = availableJornadas.indexOf(currentCalendarJornada);
            const isFirstJornada = currentIndex <= 0;
            const isLastJornada = currentIndex >= availableJornadas.length - 1;

            // Verificar se h√° √©pocas anteriores/seguintes dispon√≠veis
            const currentEpochElement = document.getElementById('epoca');
            if (currentEpochElement) {
                const currentEpoch = currentEpochElement.value;
                const epochIndex = availableEpocas.indexOf(currentEpoch);

                // √âpoca anterior (√≠ndice maior, pois est√° em ordem decrescente)
                const hasPreviousEpoca = epochIndex < availableEpocas.length - 1;
                const hasNextEpoca = epochIndex > 0;

                // Mostrar label de √©poca anterior se estiver na primeira jornada
                if (isFirstJornada && hasPreviousEpoca) {
                    prevBtn.disabled = false;
                    const prevEpoca = availableEpocas[epochIndex + 1];
                    const prevEpocaFormatted = prevEpoca.replace('_', '/');
                    prevEpocaLabel.textContent = `‚Üê ${prevEpocaFormatted}`;
                    prevEpocaLabel.style.display = 'block';
                    prevEpocaLabel.onclick = () => switchToPreviousEpoca();
                } else {
                    prevBtn.disabled = isFirstJornada;
                    prevEpocaLabel.style.display = 'none';
                }

                // Mostrar label de pr√≥xima √©poca se estiver na √∫ltima jornada
                if (isLastJornada && hasNextEpoca) {
                    nextBtn.disabled = false;
                    const nextEpoca = availableEpocas[epochIndex - 1];
                    const nextEpocaFormatted = nextEpoca.replace('_', '/');
                    nextEpocaLabel.textContent = `${nextEpocaFormatted} ‚Üí`;
                    nextEpocaLabel.style.display = 'block';
                    nextEpocaLabel.onclick = () => switchToNextEpoca();
                } else {
                    nextBtn.disabled = isLastJornada;
                    nextEpocaLabel.style.display = 'none';
                }
            } else {
                prevBtn.disabled = isFirstJornada;
                nextBtn.disabled = isLastJornada;
                prevEpocaLabel.style.display = 'none';
                nextEpocaLabel.style.display = 'none';
            }
        }

        // Atualizar calend√°rio de jogos
        function updateCalendar() {
            const gamesList = document.getElementById('gamesList');

            if (!currentCalendarJornada) {
                gamesList.innerHTML = '<div class="no-games-message">Selecione uma jornada para ver os jogos</div>';
                return;
            }

            // Extrair divis√£o num√©rica e grupo do label formatado
            // Ex: "1¬™ Divis√£o" -> div=1, group=null
            // Ex: "2¬™ Divis√£o - Grupo A" -> div=2, group="A"
            let targetDivision = null;
            let targetGroup = null;

            if (currentCalendarDivision) {
                const divMatch = currentCalendarDivision.match(/^(\d+)¬™ Divis√£o(?:\s*-\s*Grupo\s*([A-Z]))?$/);
                if (divMatch) {
                    targetDivision = divMatch[1]; // "1" ou "2"
                    targetGroup = divMatch[2] || null; // "A", "B", "C" ou null
                }
            }

            // Usar dados do calend√°rio (csv_modalidades) que tem TODOS os jogos (realizados e futuros)
            let games = sampleData.matches.filter(match => {
                const jornada = parseInt(match.jornada);
                const matchDiv = match.division ? match.division.toString() : null;
                const matchGroup = match.grupo || null;

                // Filtrar por jornada
                if (jornada !== currentCalendarJornada) return false;

                // Filtrar por divis√£o e grupo se selecionados
                if (targetDivision) {
                    // Comparar divis√£o (pode ser "2" ou "2.0")
                    const divMatch = matchDiv && (matchDiv == targetDivision ||
                        parseFloat(matchDiv) == parseFloat(targetDivision));
                    if (!divMatch) return false;

                    // Se tem grupo no label, filtrar por grupo tamb√©m
                    if (targetGroup) {
                        if (matchGroup !== targetGroup) return false;
                    }
                }

                return true;
            });

            if (games.length === 0) {
                gamesList.innerHTML = '<div class="no-games-message">Nenhum jogo encontrado para esta jornada</div>';
                return;
            }

            // Para cada jogo do calend√°rio, buscar info de ELO do rawEloData
            games = games.map(game => {
                // Procurar jogo correspondente no rawEloData para pegar info de ELO
                const eloMatch = sampleData.rawEloData ? sampleData.rawEloData.find(m =>
                    m.Jornada == game.jornada &&
                    normalizeTeamName(m['Equipa 1']) === normalizeTeamName(game.team1) &&
                    normalizeTeamName(m['Equipa 2']) === normalizeTeamName(game.team2)
                ) : null;

                return {
                    ...game,
                    eloDelta1: eloMatch ? eloMatch['Elo Delta 1'] : null,
                    eloDelta2: eloMatch ? eloMatch['Elo Delta 2'] : null
                };
            });

            // Renderizar jogos
            gamesList.innerHTML = '';
            games.forEach(game => {
                const gameItem = createGameItem(game);
                gamesList.appendChild(gameItem);
            });
        }

        // Criar elemento HTML de um jogo
        function createGameItem(game) {
            const div = document.createElement('div');

            // Suportar tanto estrutura de rawEloData quanto de matches
            const team1 = normalizeTeamName(game.team1 || game['Equipa 1']);
            const team2 = normalizeTeamName(game.team2 || game['Equipa 2']);

            // Obter resultados
            const result1 = game.score1 !== undefined && game.score1 !== null ? game.score1 :
                (game['Resultado 1'] || game['Golos 1'] || game['Golos Equipa 1'] || null);
            const result2 = game.score2 !== undefined && game.score2 !== null ? game.score2 :
                (game['Resultado 2'] || game['Golos 2'] || game['Golos Equipa 2'] || null);

            // Verificar se jogo foi realizado (resultado pode ser 0, ent√£o usar null check)
            const hasResult = (result1 !== null && result1 !== undefined && result1 !== '') &&
                (result2 !== null && result2 !== undefined && result2 !== '');

            // Data e hora do jogo
            const gameDate = game.date || game.Data || game.Dia || '';
            const gameTime = game.time || game.Hora || '';
            const hasDate = gameDate && gameDate !== '';

            div.className = `game-item ${hasResult ? 'played' : 'not-played'}`;

            // Obter informa√ß√µes das equipas
            const team1Info = getCourseInfo(team1);
            const team2Info = getCourseInfo(team2);

            // Data e hora do jogo formatadas
            let dateStr = '';
            if (hasDate) {
                dateStr = formatGameDate(gameDate);
                if (gameTime) {
                    dateStr += ` ‚Ä¢ ${gameTime}`;
                }
            }

            // Resultado
            let scoreHtml = '';
            if (hasResult) {
                scoreHtml = `<div class="game-score">${result1} - ${result2}</div>`;
            } else {
                scoreHtml = '<div class="game-vs">vs</div>';
            }

            // Mudan√ßas de ELO (s√≥ aparece se jogo foi realizado)
            const elo1Delta = game.eloDelta1 ? parseInt(game.eloDelta1) :
                (game['Elo Delta 1'] ? parseInt(game['Elo Delta 1']) : 0);
            const elo2Delta = game.eloDelta2 ? parseInt(game.eloDelta2) :
                (game['Elo Delta 2'] ? parseInt(game['Elo Delta 2']) : 0);

            const elo1Html = hasResult && elo1Delta !== 0 ?
                `<span class="game-elo-change ${elo1Delta > 0 ? 'positive' : 'negative'}">${elo1Delta > 0 ? '+' : ''}${elo1Delta}</span>` : '';
            const elo2Html = hasResult && elo2Delta !== 0 ?
                `<span class="game-elo-change ${elo2Delta > 0 ? 'positive' : 'negative'}">${elo2Delta > 0 ? '+' : ''}${elo2Delta}</span>` : '';

            // Emblemas
            const emblem1Html = team1Info.emblemPath ?
                `<img src="${team1Info.emblemPath}" class="game-team-emblem" alt="${team1}" onerror="this.style.display='none'">` : '';
            const emblem2Html = team2Info.emblemPath ?
                `<img src="${team2Info.emblemPath}" class="game-team-emblem" alt="${team2}" onerror="this.style.display='none'">` : '';

            div.innerHTML = `
                <div class="game-date">${dateStr}</div>
                <div class="game-teams">
                    <div class="game-team home">
                        ${elo1Html}
                        ${emblem1Html}
                        <span class="game-team-name">${team1}</span>
                    </div>
                    ${scoreHtml}
                    <div class="game-team away">
                        <span class="game-team-name">${team2}</span>
                        ${emblem2Html}
                        ${elo2Html}
                    </div>
                </div>
            `;

            return div;
        }

        // Formatar data do jogo
        function formatGameDate(dateStr) {
            if (!dateStr) return '';

            // Tentar diferentes formatos de data
            const date = new Date(dateStr);
            if (isNaN(date.getTime())) return dateStr; // Se n√£o conseguir parsear, retorna string original

            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = date.getFullYear();

            return `${day}/${month}/${year}`;
        }

        // Sincronizar calend√°rio quando divis√£o/grupo da classifica√ß√£o mudar
        function syncCalendarWithRankings() {
            // Sincronizar divis√£o do calend√°rio com a classifica√ß√£o
            if (currentDivision && currentDivision !== currentCalendarDivision) {
                currentCalendarDivision = currentDivision;

                // Atualizar bot√µes de divis√£o
                document.querySelectorAll('#calendarDivisionSelector .division-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.textContent === currentDivision);
                });
            }

            // Atualizar calend√°rio se j√° houver jornada selecionada
            if (currentCalendarJornada) {
                updateCalendar();
            }
        }

        // ========== FIM DAS FUN√á√ïES DO CALEND√ÅRIO ==========

        // Fun√ß√µes processadoras (iguais √†s que j√° te preparei)
        function processRankings(data) {
            DebugUtils.debugProcessedData('rankings', data.length, data[0]);

            data.forEach(row => {
                if (!row.Equipa) return;

                // Determinar a chave principal baseada em Divis√£o + Grupo
                let mainKey;
                let divisao = row.Divisao || row['Divis√£o'];
                let grupo = row.Grupo;

                // Tratar valores vazios ou nan
                if (!divisao || divisao === 'nan' || divisao === 'NaN' || divisao === '') {
                    divisao = null;
                }
                if (!grupo || grupo === 'nan' || grupo === 'NaN' || grupo === '') {
                    grupo = null;
                }

                // Determinar mainKey
                if (!divisao && !grupo) {
                    // Liga √∫nica sem divis√µes nem grupos
                    mainKey = 'geral';
                } else if (divisao && grupo) {
                    // Tem divis√£o e grupo: "2¬™ Divis√£o - Grupo A"
                    mainKey = `${divisao}¬™ Divis√£o - Grupo ${grupo}`;
                } else if (divisao) {
                    // S√≥ tem divis√£o: "1¬™ Divis√£o" ou "2¬™ Divis√£o"
                    mainKey = `${divisao}¬™ Divis√£o`;
                } else {
                    // S√≥ tem grupo (caso raro)
                    mainKey = `Grupo ${grupo}`;
                }

                DebugUtils.debugRankingsProcessing('processing_row', { team: row.Equipa, divisao, grupo, key: mainKey });

                // Obter informa√ß√µes do curso
                const normalizedTeamName = normalizeTeamName(row.Equipa);
                const courseInfo = getCourseInfo(normalizedTeamName);

                const team = {
                    name: normalizedTeamName,
                    division: divisao || mainKey,
                    group: grupo,
                    color: courseInfo.primaryColor,
                    secondaryColor: courseInfo.secondaryColor,
                    fullName: courseInfo.fullName,
                    nucleus: courseInfo.nucleus,
                    emblemPath: courseInfo.emblemPath
                };

                const existingTeam = sampleData.teams.find(t => t.name === team.name);
                if (!existingTeam) {
                    sampleData.teams.push(team);
                    sampleData.eloHistory[team.name] = [];
                } else {
                    console.warn('‚ö†Ô∏è Equipa DUPLICADA detectada:', team.name, 'j√° existe em sampleData.teams');
                }

                if (!sampleData.rankings[mainKey]) sampleData.rankings[mainKey] = [];
                sampleData.rankings[mainKey].push({
                    team: normalizedTeamName,
                    points: parseInt(row.pontos) || 0,
                    wins: parseInt(row.vitorias) || 0,
                    draws: parseInt(row.empates) || 0,
                    losses: parseInt(row.derrotas) || 0,
                    noShows: parseInt(row.faltas_comparencia) || 0,
                    goals: parseInt(row.golos_marcados) || 0,
                    conceded: parseInt(row.golos_sofridos) || 0,
                    group: grupo
                });
            });

            DebugUtils.debugRankingsProcessing('rankings_complete', { keys: Object.keys(sampleData.rankings), details: sampleData.rankings });

            DebugUtils.debugFileLoading('rankings_processed', sampleData.rankings);

            // Limpar cache de equipas qualificadas quando rankings mudam
            qualifiedTeamsCache = null;

            // Verificar duplicatas na lista de teams (apenas em modo debug)
            DebugUtils.debugFileLoading('teams_processed', sampleData.teams.length);

            // Carregar brackets depois de processar classifica√ß√µes
            // Isso garante que getQualifiedTeams() ter√° dados dispon√≠veis
            setTimeout(() => {
                createRealBracket();
            }, 100);
        }

        function processMatches(data) {
            // Analisar sistema de playoff/liguilha ao processar os jogos
            analyzePlayoffSystem(data);

            data.forEach(row => {
                if (!row["Equipa 1"] || !row["Equipa 2"]) return;

                // Extrair golos (podem estar vazios para jogos futuros)
                const golos1 = row["Golos 1"];
                const golos2 = row["Golos 2"];

                sampleData.matches.push({
                    jornada: row.Jornada,
                    team1: row["Equipa 1"].trim(),
                    team2: row["Equipa 2"].trim(),
                    score1: golos1 !== '' && golos1 !== undefined ? parseInt(golos1) : null,
                    score2: golos2 !== '' && golos2 !== undefined ? parseInt(golos2) : null,
                    date: row.Dia || row.Data,
                    time: row.Hora || '',
                    division: row['Divis√£o'] || row.Divisao,
                    grupo: row.Grupo
                });
            });
        }        /**
         * Analisa os dados dos jogos para detectar o sistema de playoff/liguilha usado
         * Identifica se usa: playoffs (E*), playoff de manuten√ß√£o (PM*), ou liguilha de manuten√ß√£o (LM*)
         */
        function analyzePlayoffSystem(matchesData) {
            const systems = {
                hasWinnerPlayoffs: false,    // E1, E2, E3L, E3
                hasMaintenancePlayoffs: false, // PM1, PM2
                hasMaintenanceLeague: false,   // LM1, LM2, LM3...
                hasPromotionSystem: false,     // Sistema de promo√ß√£o direto
                divisions: new Set(),
                groups: new Set()
            };

            matchesData.forEach(row => {
                const jornada = (row.Jornada || '').toString().trim().toUpperCase();
                const divisao = row['Divis√£o'] || row['Divisao'];
                const grupo = row.Grupo;

                // Detectar divis√µes e grupos
                if (divisao) systems.divisions.add(divisao);
                if (grupo && grupo !== 'nan' && grupo !== 'NaN') systems.groups.add(grupo);

                // Detectar tipos de playoff/liguilha
                if (jornada.startsWith('E') && /^E\d/.test(jornada)) {
                    systems.hasWinnerPlayoffs = true;
                } else if (jornada.startsWith('PM')) {
                    systems.hasMaintenancePlayoffs = true;
                } else if (jornada.startsWith('LM')) {
                    systems.hasMaintenanceLeague = true;
                }
            });

            // Determinar se h√° sistema de promo√ß√£o baseado na estrutura
            systems.hasPromotionSystem = systems.divisions.size > 1;

            // Salvar informa√ß√µes globalmente
            playoffSystemInfo = {
                ...systems,
                divisions: Array.from(systems.divisions),
                groups: Array.from(systems.groups)
            };

            DebugUtils.debugRankingsProcessing('playoff_system_detected', playoffSystemInfo);
        }

        // Fun√ß√£o auxiliar para verificar se existem ajustes intergrupos reais (n√£o-zero)
        function hasRealInterGroupAdjustments(teamInterGroupAdjustments, rawEloData = null) {
            // M√©todo 1: Verificar atrav√©s dos ajustes coletados
            const hasAdjustmentsFromTeamData = Object.values(teamInterGroupAdjustments).some(adjustments =>
                adjustments.some(adj => {
                    // Verificar se h√° ajuste n√£o-zero ou diferen√ßa significativa no ELO final
                    const hasNonZeroAdjustment = adj.adjustment && adj.adjustment !== 0;
                    const hasSignificantEloChange = adj.finalElo && adj.initialElo &&
                        Math.abs(adj.finalElo - adj.initialElo) > 1; // Toler√¢ncia de 1 ponto
                    return hasNonZeroAdjustment || hasSignificantEloChange;
                })
            );

            // M√©todo 2: Verificar diretamente nos dados brutos se dispon√≠vel
            let hasAdjustmentsFromRawData = false;
            if (rawEloData && rawEloData.length > 0) {
                hasAdjustmentsFromRawData = rawEloData.some(row => {
                    // Verificar linhas "Inter-Group" com ajustes n√£o-zero
                    if (row.Jornada === "Inter-Group" && row["Equipa 1"]) {
                        const adjustment = parseInt(row["Elo Delta 1"]) || 0;
                        return adjustment !== 0;
                    }
                    // Verificar tamb√©m ajustes nos jogos normais
                    const interGroupAdj1 = parseInt(row["Inter Group Adjustment 1"]) || 0;
                    const interGroupAdj2 = parseInt(row["Inter Group Adjustment 2"]) || 0;
                    return interGroupAdj1 !== 0 || interGroupAdj2 !== 0;
                });
            }

            const result = hasAdjustmentsFromTeamData || hasAdjustmentsFromRawData;
            DebugUtils.debugProcessedData('ajustes intergrupos', result ? 1 : 0, {
                fromTeamData: hasAdjustmentsFromTeamData,
                fromRawData: hasAdjustmentsFromRawData,
                final: result
            });

            return result;
        }

        // ==================== PROCESSADOR DE HIST√ìRICO ELO ====================

        class EloHistoryProcessor {
            constructor() {
                this.teamEloByRound = {};
                this.teamInitialElo = {};
                this.gamesDates = {};
                this.teamInterGroupAdjustments = {};
                this.playoffGames = {};
                this.playoffDates = {};
                this.allDates = [];
                this.hasInterGroupAdjustments = false;
            }

            /**
             * Processa dados de hist√≥rico ELO
             */
            process(data, initialElosFromFile = {}) {
                DebugUtils.debugProcessedData('hist√≥rico ELO', data.length, `${data.length} jogos`);

                // Guardar dados brutos para processamento do bracket
                sampleData.rawEloData = data;

                // Verificar se n√£o h√° jogos
                if (this._hasNoGames(data, initialElosFromFile)) {
                    return;
                }

                // Processar todos os jogos e extrair informa√ß√µes
                this._extractGameData(data, initialElosFromFile);

                // Organizar datas e ajustes
                this._organizeDatesAndAdjustments();

                // Construir hist√≥rico de ELO para cada equipa
                this._buildEloHistories(initialElosFromFile);

                // Garantir consist√™ncia nos pontos do gr√°fico
                this._ensureConsistentPoints();

                DebugUtils.debugEloHistoryFinal(sampleData.eloHistory);
            }

            /**
             * Verifica se n√£o h√° jogos para processar
             */
            _hasNoGames(data, initialElosFromFile) {
                const hasNoGames = !data || data.length === 0 ||
                    (data.length === 1 && Object.values(data[0]).every(v => !v || v === ''));

                if (hasNoGames && Object.keys(initialElosFromFile).length > 0) {
                    DebugUtils.debugProcessedData('sem jogos', Object.keys(initialElosFromFile).length, 'usar ELOs iniciais do ficheiro');

                    Object.keys(initialElosFromFile).forEach(teamName => {
                        const initialElo = initialElosFromFile[teamName];
                        sampleData.eloHistory[teamName] = [initialElo];
                    });

                    return true;
                }

                return false;
            }

            /**
             * Extrai dados de jogos e ajustes intergrupos
             */
            _extractGameData(data, initialElosFromFile) {
                data.forEach(row => {
                    // Processar ajustes intergrupos
                    if (row.Jornada === "Inter-Group" && row["Equipa 1"]) {
                        this._extractInterGroupAdjustment(row);
                        return;
                    }

                    if (!row["Equipa 1"] || !row["Equipa 2"]) return;

                    const round = row.Jornada;
                    const team1 = normalizeTeamName(row["Equipa 1"]);
                    const team2 = normalizeTeamName(row["Equipa 2"]);
                    const finalElo1 = parseInt(row["Final Elo 1"]) || parseInt(row["Elo Depois 1"]) || null;
                    const finalElo2 = parseInt(row["Final Elo 2"]) || parseInt(row["Elo Depois 2"]) || null;
                    const initialElo1 = parseInt(row["Elo Antes 1"]) || null;
                    const initialElo2 = parseInt(row["Elo Antes 2"]) || null;
                    const gameDate = row.Dia ? new Date(row.Dia) : null;

                    // Guardar ELO inicial
                    this._setInitialElo(team1, initialElosFromFile[team1], initialElo1);
                    this._setInitialElo(team2, initialElosFromFile[team2], initialElo2);

                    // Processar ajustes intergrupos dos jogos normais
                    this._processGameInterGroupAdjustments(row, team1, team2, round, gameDate);

                    // Separar jornadas num√©ricas dos playoffs
                    const roundNum = parseInt(round);
                    if (!isNaN(roundNum)) {
                        this._processRegularRound(roundNum, team1, team2, finalElo1, finalElo2, gameDate);
                    } else if (round.startsWith('E')) {
                        this._processPlayoffRound(round, team1, team2, finalElo1, finalElo2, gameDate);
                    }
                });
            }

            /**
             * Extrai ajustes intergrupos especiais
             */
            _extractInterGroupAdjustment(row) {
                const teamName = normalizeTeamName(row["Equipa 1"]);
                const adjustment = parseInt(row["Elo Delta 1"]) || 0;
                const finalElo = parseInt(row["Final Elo 1"]) || parseInt(row["Elo Depois 1"]) || 0;

                if (adjustment !== 0) {
                    if (!this.teamInterGroupAdjustments[teamName]) {
                        this.teamInterGroupAdjustments[teamName] = [];
                    }
                    this.teamInterGroupAdjustments[teamName].push({
                        round: "Inter-Group",
                        adjustment: adjustment,
                        finalElo: finalElo,
                        date: null
                    });
                    DebugUtils.debugInterGroupAdjustment(teamName, adjustment);
                }
            }

            /**
             * Define ELO inicial de uma equipa
             */
            _setInitialElo(teamName, fileElo, gameElo) {
                if (!this.teamInitialElo[teamName]) {
                    this.teamInitialElo[teamName] = fileElo || gameElo || 1500;
                }
            }

            /**
             * Processa ajustes intergrupos de jogos normais
             */
            _processGameInterGroupAdjustments(row, team1, team2, round, gameDate) {
                const interGroupAdj1 = parseInt(row["Inter Group Adjustment 1"]) || 0;
                const interGroupAdj2 = parseInt(row["Inter Group Adjustment 2"]) || 0;

                if (interGroupAdj1 !== 0) {
                    if (!this.teamInterGroupAdjustments[team1]) {
                        this.teamInterGroupAdjustments[team1] = [];
                    }
                    this.teamInterGroupAdjustments[team1].push({
                        round: round,
                        adjustment: interGroupAdj1,
                        date: gameDate
                    });
                }

                if (interGroupAdj2 !== 0) {
                    if (!this.teamInterGroupAdjustments[team2]) {
                        this.teamInterGroupAdjustments[team2] = [];
                    }
                    this.teamInterGroupAdjustments[team2].push({
                        round: round,
                        adjustment: interGroupAdj2,
                        date: gameDate
                    });
                }
            }

            /**
             * Processa jornada regular (fase de grupos)
             */
            _processRegularRound(roundNum, team1, team2, finalElo1, finalElo2, gameDate) {
                if (gameDate && !this.gamesDates[roundNum]) {
                    this.gamesDates[roundNum] = gameDate;
                }

                if (!this.teamEloByRound[team1]) this.teamEloByRound[team1] = {};
                if (!this.teamEloByRound[team2]) this.teamEloByRound[team2] = {};

                this.teamEloByRound[team1][roundNum] = finalElo1;
                this.teamEloByRound[team2][roundNum] = finalElo2;
            }

            /**
             * Processa jornada de playoffs
             */
            _processPlayoffRound(round, team1, team2, finalElo1, finalElo2, gameDate) {
                if (!this.playoffGames[round]) {
                    this.playoffGames[round] = [];
                }
                this.playoffGames[round].push({
                    team1: team1,
                    team2: team2,
                    finalElo1: finalElo1,
                    finalElo2: finalElo2,
                    date: gameDate
                });
            }

            /**
             * Organiza datas e verifica ajustes intergrupos
             */
            _organizeDatesAndAdjustments() {
                // Data inicial baseada na √©poca
                const initialDate = currentEpoca === '25_26' ? new Date('2025-09-01') : new Date('2024-09-01');
                this.allDates = [initialDate];

                // Datas da fase de grupos
                const sortedRounds = Object.keys(this.gamesDates).sort((a, b) => parseInt(a) - parseInt(b));
                sortedRounds.forEach(round => this.allDates.push(this.gamesDates[round]));

                // Datas dos playoffs
                const playoffOrder = ['E1', 'E2', 'E3L', 'E3'];
                playoffOrder.forEach(phase => {
                    if (this.playoffGames[phase] && this.playoffGames[phase].length > 0) {
                        const phaseDate = this.playoffGames[phase][0].date;
                        if (phaseDate) {
                            this.playoffDates[phase] = phaseDate;
                            this.allDates.push(phaseDate);
                        }
                    }
                });

                DebugUtils.debugProcessedData('jogos de playoffs', Object.keys(this.playoffGames).length, Object.keys(this.playoffGames));
                DebugUtils.debugProcessedData('datas dos playoffs', Object.keys(this.playoffDates).length, this.playoffDates);

                // Verificar ajustes intergrupos
                this.hasInterGroupAdjustments = hasRealInterGroupAdjustments(this.teamInterGroupAdjustments);

                if (this.hasInterGroupAdjustments && this.allDates.length > 1) {
                    const lastGameDate = this.allDates[this.allDates.length - 1];
                    const adjustmentDate = new Date(lastGameDate);
                    adjustmentDate.setDate(adjustmentDate.getDate() + 1);
                    this.allDates.push(adjustmentDate);
                    DebugUtils.debugProcessedData('ajustes intergrupos programados', 1, adjustmentDate.toLocaleDateString('pt-PT'));
                } else if (this.hasInterGroupAdjustments) {
                    const fallbackDate = new Date('2025-06-01');
                    this.allDates.push(fallbackDate);
                }

                DebugUtils.debugProcessedData('ajustes intergrupos encontrados', this.hasInterGroupAdjustments ? 1 : 0, this.hasInterGroupAdjustments);

                currentModalityHasAdjustments = this.hasInterGroupAdjustments;
                sampleData.gamesDates = this.allDates;

                DebugUtils.debugProcessedData('equipas com hist√≥rico ELO', Object.keys(this.teamEloByRound).length, Object.keys(this.teamEloByRound));
                DebugUtils.debugProcessedData('ELO inicial das equipas', Object.keys(this.teamInitialElo).length, this.teamInitialElo);
                DebugUtils.debugProcessedData('ajustes intergrupos', Object.keys(this.teamInterGroupAdjustments).length, this.teamInterGroupAdjustments);
                DebugUtils.debugProcessedData('datas dos jogos', sampleData.gamesDates ? sampleData.gamesDates.length : 0, sampleData.gamesDates);
            }

            /**
             * Constr√≥i hist√≥rico de ELO para cada equipa
             */
            _buildEloHistories(initialElosFromFile) {
                const allGameRounds = Object.keys(this.gamesDates).sort((a, b) => parseInt(a) - parseInt(b));
                const playoffOrder = ['E1', 'E2', 'E3L', 'E3'];

                // Equipas que jogaram
                Object.keys(this.teamEloByRound).forEach(teamName => {
                    const initialElo = initialElosFromFile[teamName] || this.teamInitialElo[teamName] || 1500;
                    const eloValues = [initialElo];
                    let currentElo = initialElo;

                    DebugUtils.debugTeamEloProcessing(teamName, initialElo, currentElo, this.teamEloByRound[teamName], allGameRounds);

                    // Fase de grupos
                    allGameRounds.forEach(round => {
                        if (this.teamEloByRound[teamName][round] !== undefined) {
                            currentElo = this.teamEloByRound[teamName][round];
                        }
                        eloValues.push(currentElo);
                    });

                    // Playoffs
                    currentElo = this._processTeamPlayoffs(teamName, playoffOrder, eloValues, currentElo);

                    // Ajustes intergrupos
                    this._applyInterGroupAdjustments(teamName, eloValues);

                    sampleData.eloHistory[teamName] = eloValues;
                    DebugUtils.debugEloAdjustments(teamName, 'final_elo', {
                        initial: eloValues[0],
                        points: eloValues.length
                    });
                });

                // Equipas que n√£o jogaram
                this._processNonPlayingTeams(initialElosFromFile, allGameRounds);
            }

            /**
             * Processa playoffs de uma equipa
             */
            _processTeamPlayoffs(teamName, playoffOrder, eloValues, currentElo) {
                playoffOrder.forEach(phase => {
                    if (this.playoffGames[phase] && this.playoffDates[phase]) {
                        const teamGame = this.playoffGames[phase].find(game =>
                            game.team1 === teamName || game.team2 === teamName
                        );

                        if (teamGame) {
                            currentElo = teamGame.team1 === teamName ? teamGame.finalElo1 : teamGame.finalElo2;
                            DebugUtils.debugProcessedData(`${teamName} ELO`, 1, `ap√≥s ${phase} = ${currentElo}`);
                        }
                        eloValues.push(currentElo);
                    }
                });

                return currentElo;
            }

            /**
             * Aplica ajustes intergrupos a uma equipa
             */
            _applyInterGroupAdjustments(teamName, eloValues) {
                if (!this.hasInterGroupAdjustments) return;

                const lastElo = eloValues[eloValues.length - 1];

                if (this.teamInterGroupAdjustments[teamName] && this.teamInterGroupAdjustments[teamName].length > 0) {
                    const interGroupAdj = this.teamInterGroupAdjustments[teamName].find(adj => adj.finalElo && adj.finalElo > 0);

                    if (interGroupAdj) {
                        const newElo = interGroupAdj.finalElo;
                        const actualAdjustment = newElo - lastElo;
                        eloValues.push(newElo);
                        DebugUtils.debugEloAdjustments(teamName, 'before_adjustments', {
                            before: lastElo,
                            after: newElo,
                            adjustment: actualAdjustment
                        });
                    } else {
                        const totalAdjustment = this.teamInterGroupAdjustments[teamName].reduce((sum, adj) => sum + adj.adjustment, 0);
                        const newElo = lastElo + totalAdjustment;
                        eloValues.push(newElo);
                        if (totalAdjustment !== 0) {
                            DebugUtils.debugEloAdjustments(teamName, 'with_adjustment', {
                                before: lastElo,
                                adjustment: totalAdjustment,
                                after: newElo
                            });
                        } else {
                            DebugUtils.debugEloAdjustments(teamName, 'no_adjustment', { elo: lastElo });
                        }
                    }
                } else {
                    eloValues.push(lastElo);
                    DebugUtils.debugEloAdjustments(teamName, 'no_intergroup', { elo: lastElo });
                }
            }

            /**
             * Processa equipas que n√£o jogaram
             */
            _processNonPlayingTeams(initialElosFromFile, allGameRounds) {
                sampleData.teams.forEach(team => {
                    if (!this.teamEloByRound[team.name]) {
                        const initialElo = initialElosFromFile[team.name] || this.teamInitialElo[team.name] || 1500;
                        const totalPoints = 1 + allGameRounds.length + Object.keys(this.playoffDates).length +
                            (this.hasInterGroupAdjustments ? 1 : 0);

                        let eloValues = new Array(totalPoints - (this.hasInterGroupAdjustments ? 1 : 0)).fill(initialElo);

                        if (this.hasInterGroupAdjustments) {
                            this._applyAdjustmentToNonPlayingTeam(team.name, initialElo, eloValues);
                        }

                        sampleData.eloHistory[team.name] = eloValues;
                    }
                });
            }

            /**
             * Aplica ajuste a equipa que n√£o jogou
             */
            _applyAdjustmentToNonPlayingTeam(teamName, initialElo, eloValues) {
                if (this.teamInterGroupAdjustments[teamName] && this.teamInterGroupAdjustments[teamName].length > 0) {
                    const interGroupAdj = this.teamInterGroupAdjustments[teamName].find(adj => adj.finalElo && adj.finalElo > 0);

                    if (interGroupAdj) {
                        const newElo = interGroupAdj.finalElo;
                        const actualAdjustment = newElo - initialElo;
                        eloValues.push(newElo);
                        DebugUtils.debugEloAdjustments(teamName, 'no_games_adjustment', {
                            initial: initialElo,
                            final: newElo,
                            adjustment: actualAdjustment
                        });
                    } else {
                        const totalAdjustment = this.teamInterGroupAdjustments[teamName].reduce((sum, adj) => sum + adj.adjustment, 0);
                        const newElo = initialElo + totalAdjustment;
                        eloValues.push(newElo);
                        if (totalAdjustment !== 0) {
                            DebugUtils.debugEloAdjustments(teamName, 'no_games_with_adjustment', {
                                initial: initialElo,
                                adjustment: totalAdjustment,
                                final: newElo
                            });
                        } else {
                            DebugUtils.debugEloAdjustments(teamName, 'no_games_no_adjustment', { initial: initialElo });
                        }
                    }
                } else {
                    eloValues.push(initialElo);
                    DebugUtils.debugEloAdjustments(teamName, 'no_games_no_intergroup', { initial: initialElo });
                }
            }

            /**
             * Garante que todas as equipas t√™m o mesmo n√∫mero de pontos
             */
            _ensureConsistentPoints() {
                const allGameRounds = Object.keys(this.gamesDates).sort((a, b) => parseInt(a) - parseInt(b));
                const expectedPoints = 1 + allGameRounds.length + Object.keys(this.playoffDates).length +
                    (this.hasInterGroupAdjustments ? 1 : 0);

                sampleData.teams.forEach(team => {
                    if (sampleData.eloHistory[team.name] && sampleData.eloHistory[team.name].length < expectedPoints) {
                        const currentValues = sampleData.eloHistory[team.name];
                        const lastElo = currentValues[currentValues.length - 1];

                        while (currentValues.length < expectedPoints) {
                            if (this.hasInterGroupAdjustments && currentValues.length === expectedPoints - 1) {
                                this._completeWithAdjustment(team.name, currentValues, lastElo);
                            } else {
                                currentValues.push(lastElo);
                            }
                        }
                        DebugUtils.debugEloAdjustments(team.name, 'completed_points', { points: expectedPoints });
                    }
                });
            }

            /**
             * Completa pontos em falta com ajuste intergrupos
             */
            _completeWithAdjustment(teamName, currentValues, lastElo) {
                if (this.teamInterGroupAdjustments[teamName] && this.teamInterGroupAdjustments[teamName].length > 0) {
                    const interGroupAdj = this.teamInterGroupAdjustments[teamName].find(adj => adj.finalElo && adj.finalElo > 0);

                    if (interGroupAdj) {
                        const newElo = interGroupAdj.finalElo;
                        const actualAdjustment = newElo - lastElo;
                        currentValues.push(newElo);
                        DebugUtils.debugEloAdjustments(teamName, 'completed_with_adjustment', {
                            final: newElo,
                            adjustment: actualAdjustment
                        });
                    } else {
                        const totalAdjustment = this.teamInterGroupAdjustments[teamName].reduce((sum, adj) => sum + adj.adjustment, 0);
                        const newElo = lastElo + totalAdjustment;
                        currentValues.push(newElo);
                        if (totalAdjustment !== 0) {
                            DebugUtils.debugEloAdjustments(teamName, 'completed_with_total_adjustment', {
                                adjustment: totalAdjustment,
                                final: newElo
                            });
                        } else {
                            DebugUtils.debugEloAdjustments(teamName, 'completed_no_adjustment', { elo: lastElo });
                        }
                    }
                } else {
                    currentValues.push(lastElo);
                    DebugUtils.debugEloAdjustments(teamName, 'completed_no_intergroup', { elo: lastElo });
                }
            }
        }

        // Fun√ß√£o wrapper para compatibilidade com c√≥digo existente
        function processEloHistory(data, initialElosFromFile = {}) {
            const processor = new EloHistoryProcessor();
            processor.process(data, initialElosFromFile);
        }

        // ==================== SISTEMA DE EVENT DELEGATION ====================

        class EventManager {
            constructor() {
                this.handlers = new Map();
                this.init();
            }

            /**
             * Inicializa event listeners delegados
             */
            init() {
                // Event delegation para toda a p√°gina
                document.addEventListener('click', (e) => this.handleClick(e));
                document.addEventListener('change', (e) => this.handleChange(e));
            }

            /**
             * Registra um handler para um seletor CSS
             */
            on(selector, eventType, handler) {
                const key = `${eventType}:${selector}`;
                if (!this.handlers.has(key)) {
                    this.handlers.set(key, []);
                }
                this.handlers.get(key).push(handler);
            }

            /**
             * Handler central para eventos de click
             */
            handleClick(event) {
                this.dispatchEvent('click', event);
            }

            /**
             * Handler central para eventos de change
             */
            handleChange(event) {
                this.dispatchEvent('change', event);
            }

            /**
             * Dispatch de eventos para handlers registrados
             */
            dispatchEvent(eventType, event) {
                for (const [key, handlers] of this.handlers) {
                    const [type, selector] = key.split(':');

                    if (type === eventType && event.target.matches(selector)) {
                        handlers.forEach(handler => handler(event));
                    }
                }
            }
        }

        // Inst√¢ncia global do gerenciador de eventos
        const eventManager = new EventManager();

        // ==================== COMPONENTES UI ====================

        /**
         * Componente base para seletores
         */
        class SelectorComponent {
            constructor(elementId) {
                this.element = document.getElementById(elementId);
                this.initialized = false;
            }

            render() {
                throw new Error('render() deve ser implementado pela subclasse');
            }

            clear() {
                if (this.element) {
                    this.element.innerHTML = '';
                }
            }
        }

        /**
         * Seletor de Divis√µes
         */
        class DivisionSelector extends SelectorComponent {
            constructor() {
                super('divisionSelector');
            }

            render() {
                this.clear();

                const structure = analyzeModalityStructure();
                const divisions = Object.keys(sampleData.rankings);

                if (divisions.length <= 1) {
                    this.element.style.display = 'none';
                    return;
                }

                this.element.style.display = 'flex';

                // Validar divis√£o atual
                if (!appState.view.division || !divisions.includes(appState.view.division)) {
                    appState.view.division = divisions[0];
                }

                divisions.forEach(division => {
                    const btn = document.createElement('button');
                    btn.className = `division-btn ${division === appState.view.division ? 'active' : ''}`;
                    btn.textContent = division;
                    btn.dataset.division = division;
                    this.element.appendChild(btn);
                });

                this.initialized = true;
            }

            setActive(division) {
                appState.view.division = division;
                appState.view.group = null;

                const buttons = this.element.querySelectorAll('.division-btn');
                buttons.forEach(btn => {
                    btn.classList.toggle('active', btn.textContent === division);
                });
            }
        }

        /**
         * Seletor de Grupos
         */
        class GroupSelector extends SelectorComponent {
            constructor() {
                super('groupSelector');
            }

            render() {
                this.clear();

                if (!sampleData.rankings || !sampleData.rankings[appState.view.division]) {
                    this.element.style.display = 'none';
                    return;
                }

                const teams = sampleData.rankings[appState.view.division];
                const groups = [...new Set(teams.map(team => team.group))].filter(group => group && group !== 'nan');

                if (groups.length === 0) {
                    this.element.style.display = 'none';
                    appState.view.group = null;
                    return;
                }

                this.element.style.display = 'flex';

                // Bot√£o "Todos"
                const allBtn = document.createElement('button');
                allBtn.className = `group-btn ${!appState.view.group ? 'active' : ''}`;
                allBtn.textContent = 'Todos';
                allBtn.dataset.group = '';
                this.element.appendChild(allBtn);

                // Bot√µes de grupos
                groups.forEach(group => {
                    const btn = document.createElement('button');
                    btn.className = `group-btn ${group === appState.view.group ? 'active' : ''}`;
                    btn.textContent = `Grupo ${group}`;
                    btn.dataset.group = group;
                    this.element.appendChild(btn);
                });

                this.initialized = true;
            }

            setActive(group) {
                const groupLetter = group ? group.replace('Grupo ', '') : null;
                appState.view.group = groupLetter;

                const buttons = this.element.querySelectorAll('.group-btn');
                buttons.forEach(btn => {
                    const btnGroup = btn.dataset.group;
                    btn.classList.toggle('active', btnGroup === (groupLetter || ''));
                });
            }
        }

        // Inst√¢ncias globais dos seletores
        const divisionSelector = new DivisionSelector();
        const groupSelector = new GroupSelector();

        // ==================== REGISTRAR EVENT HANDLERS ====================

        // Seletores de √©poca e modalidade
        eventManager.on('#epoca', 'change', (e) => changeEpoca(e.target.value));
        eventManager.on('#modalidade', 'change', (e) => changeModalidade(e.target.value));

        // Bot√µes de zoom
        eventManager.on('[data-zoom="in"]', 'click', () => zoomChart(1.2));
        eventManager.on('[data-zoom="out"]', 'click', () => zoomChart(0.8));
        eventManager.on('[data-zoom="reset"]', 'click', () => resetZoom());
        eventManager.on('[data-action="toggle-pan"]', 'click', () => togglePanMode());

        // Seletores de divis√£o e grupo
        eventManager.on('.division-btn', 'click', (e) => {
            const division = e.target.dataset.division;
            if (division) {
                divisionSelector.setActive(division);
                groupSelector.render();
                updateRankingsTable();
                updateBracket();
            }
        });

        eventManager.on('.group-btn', 'click', (e) => {
            const group = e.target.dataset.group;
            groupSelector.setActive(group);
            updateRankingsTable();
        });

        // Navega√ß√£o de jornadas
        eventManager.on('[data-jornada-nav="prev"]', 'click', () => changeJornada(-1));
        eventManager.on('[data-jornada-nav="next"]', 'click', () => changeJornada(1));

        // Bot√µes de debug
        eventManager.on('[data-debug="enable"]', 'click', () => DebugUtils.setDebugEnabled(true, false));
        eventManager.on('[data-debug="enable-all"]', 'click', () => DebugUtils.setDebugEnabled(true, true));
        eventManager.on('[data-debug="disable"]', 'click', () => DebugUtils.setDebugEnabled(false));
        eventManager.on('[data-debug="close"]', 'click', () => {
            document.getElementById('debug-panel').style.display = 'none';
        });

        // Checkboxes de equipas (delega√ß√£o para o container)
        eventManager.on('#teamSelector input[type="checkbox"]', 'change', (e) => {
            const teamName = e.target.dataset.teamName || e.target.id.replace('team-', '').replace(/_/g, ' ');
            toggleTeam(teamName);
        });

        // Filtros r√°pidos
        eventManager.on('[data-filter="top3"]', 'click', () => filterTop3());
        eventManager.on('[data-filter="division"]', 'click', (e) => {
            const division = e.target.dataset.division;
            if (division) filterDivision(division);
        });

        // Inicializar quando a p√°gina carregar
        document.addEventListener('DOMContentLoaded', initApp);

        // Event listeners para controles de teclado
        document.addEventListener('keydown', (event) => {
            // Verificar se o usu√°rio est√° editando texto
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                return;
            }

            switch (event.key) {
                case '+':
                case '=':
                    event.preventDefault();
                    zoomChart(1.2);
                    break;
                case '-':
                    event.preventDefault();
                    zoomChart(0.8);
                    break;
                case '0':
                    event.preventDefault();
                    resetZoom();
                    break;
                case 'p':
                case 'P':
                    event.preventDefault();
                    togglePanMode();
                    break;
            }
        });

        // Atualizar labels din√¢micos quando a janela for redimensionada
        window.addEventListener('resize', () => {
            setTimeout(() => {
                updateDynamicTeamLabels();
            }, 200);
        });
        // Inicializar sistema de debug (desativado por padr√£o)
        document.addEventListener('DOMContentLoaded', function () {
            // Para ativar debug, descomente a linha abaixo:
            // DebugUtils.setDebugEnabled(true, false, ['inform√°tica', 'informatica']);
        });
    </script>
</body>

</html>